(* ::Package:: *)

AppendTo[$Path,NotebookDirectory[]];


(* ::Code::Initialization::GrayLevel[0]:: *)
BeginPackage["Trankvility`",{"OOP`"}];


Today


(* ::Code::Initialization::GrayLevel[0]:: *)
Unprotect["Trankvility`*"];
ClearAll["Trankvility`*"];
ClearAll["Trankvility`Private`*"];


(* ::Subsection:: *)
(*a few init functions before the definitions to run on startup*)


(* ::Code::Initialization::GrayLevel[0]:: *)
fftshift::usage = "Center Fourier transform (phase-preserving)";
ifftshift::usage = "Uncenter Fourier transform (phase-preserving)";
imageCenter::usage = "Return coordinates of image center";
hannWindow::usage = "Return 2D Hann window (useful for FFT)";
plotRanger::usage = "Automatically adjust contrast within nsigma deviations of the mean";
bandPass::usage = "Interactive Fourier band pass filter";
bedOfNails::usage = "Bed of nails function with xp, yp -> spacings, and sz -> size";
showFFT::usage = "Quick! Show me fftshifted FFT magnitude";
randomCheck::usage = "Is this still alive?";
baseFFT::usage = "FFT amplitude with default Hann window filtering";
JsonImport::usage="ZImport[\"file.json\"] will import a compressed Mathematica expression from file.json.";
JsonExport::usage="ZExport[\"file.json\", data] will export data as a compressed Mathematica expression to file.json.";
todaysDate::usage="returns 2019-01-01 type of string";
saveState::usage = "save variables and the notebook itself";
getState::usage = "recover saved variables and the notebook itself";
initNB::usage="commands to initate styling and other features in the notebook";
singleSpectraViz::usage="pick and look and spectra with a 2D slider";
singleSpectraMapper::usage="pick and look and spectra with a z-image of the soiurce area";
spectraPicker::usage="pick spectra by point and click witn a mouse";
meanSpectraPlot::usage="plot average curve with errorbars from hypespectral data, containing 'bias' vs some X";
getLargestClusters::usage="do a sequence of dimensionality reduction and clustering. Prospectively needs to be a monad";
plotClusters::usage="plot Clusters generated by getClusteredData";
plotClusters1D::usage="plot clusters of 1D data with errorbars. So far tested on Hierarchical clustering";
chanHistogram::usage = "plot histograms of hypespectral arrays. 'bias' channel or its analogue should
be specified";
pointsToHistogram3D::usage="convert point cloud to 3D histogram";
figureToClipboard::usage = "put figure into Clipboard. Saved via png";
hierarchy::usage="hierarchical clustering, returning cluster object and its stats down to 'truncate' levels";
pcaScree::usage="PCA scree plots, fractional and cumulative";
hierarchyPlots::usage="returns Dendrogram plot with log Distance, leaf labels corresponding to number of members in the cluster and clusters
with truncation";
outliersAndClusters::usage="split Cluster object into outliers and residual clusters. Length of residual clusters can be gained from #[[-2]] for each elemetn";
chainAssoc::usage="insert input and its modification into association, creating nested association/dataset 
type objects";
growForkBranch::usage="simultaneously copies the data under path into 's' and forks a mod(data) into new named field 
(grows a double-fork out of a branch)";
growBranch::usage="either inject data into assoc; or nest a given branch with a copy/mod(copy) of the data";
forkBranch::usage="adds nested branch at arbitrary point and with arbitrary data";
nestedAssociate::"add a field to nested association";
clearPlot::usage="updating theme for presentation figures via Show";
distMatrixHistogram::usage="plot histogram of distance matrix calculated from supplied data";
dimReducePacket::usage="return association with reducer functions, reduced vectors and reconstructed data";
histogram2D::usage="simple 2D histogram of a nD hyperspectral array. Last dimension is assumed to be the variable coordinate";
(*added to git*)
quickShape::usage="quickly reshape List from 2D to 3D or otherwise. Assumes that last dimension 
remains unchanged (e.g. hyperspectral data)";
dimCheck::usage="check dimensionality of array. Returns true of d>= dimensionality";
adjustPlot::usage="a nice restyler. Supply [plot, ListofLineProps, graphicsOptions]";
CloseAllInputCells::usage="good for demo. Close all inputs";
OpenAllInputsCells::usage="good for demo. Open all inputs";
testListAssociation::usage="quick peek at keys, dimensions or contents of the variable, depending on type and size";
colorGrads::usage="default color gradients with their namelabels for use with the ColorFunction";
niceMatrixPlot::usage="autoscales chosen colorbar onto the range of data, and shows the colorbar";
physicalTicks::usage="provides an array of {i,tick[i]} for use in labeling array ticks";
fitFunc1D::usage="helper function for 1D fitting. Strict requirement on formatting. See header for details";
assignSymbol::usage="assign value to symbol expressed by string";
reportGrid::usage="quick peek at a grid 3Ds file (attrs + a few plots); Overloaded to take advatnage of existing grid->Association conversions";
colobar::usage="generate density plot scaled and shaped as a colorbar on the right. Takes care of tricky color-scaling";
imageScalebar::usage ="feed 2D channel (zf, isoslice etc) and attrs -> get image, scalebar and colorbar";
normalize::usage="curried function for normalization and flattening";
denoise::usage="curried function for PCA denoising";
differentiate::usage="curried function for tunable differentiation (via \[Sigma]-parameter)";
plotStyle::usage="default rescale of labels and line thicknesses on the plot";
readDat::usage="import single dat file";
NiceGridDark::usage="version of NiceGrid optimized for dark background";
kill::usage="terminate after n seconds -> first parameter";
head::usage="preview a structure by showing first n members (n can be negative -> tail)";
headRandom::usage="preview a structure by showing n Random  members (n can only be positive)";
packVars::usage="collect large enough variables and pack the whole notebook too";
unPackVars::usage="extract variables from the association that captures the notebook";
colorbar::usage="";
meshgrid::usage="Wolfram centric meshgrid";
findBlobs::usage="detect blobs with sckikit";
logBlob::usage="detect blobs with Wolfram";
plotStylePhys::usage="modified plotStyle with square shape and gridlines";
openNotebook::usage="open notebook from a given address file";
figToClip::usage="quickly capture and copy whole figure to clipboard (via local storage instance)";
figToSVG::usage="save figure as SVG file, and copy the filepath into Clipboard";
figToPNG::usage="save figure as PNG file, and copy the filepath into Clipboard";
pipe::usage="synonym of RightComposition";
reveal::usage="synonym of GeneralUtilities`PrintDefinitions";
customTicks::usage="wrapping Charting`ScaledTicks function";
addLabel::usage="labels a graphics object, allowing offsets and custom labels";
logBlobScaler::usage="scaled blob transformation";
tabbedNotebook::usage="create new tabbed notebook";
nmfPY::usage="NMF algo from scikit-learn";
kpcaPY::usage="kernel PCA alog from scikit-learn";
pyBgEstimate::usage="phoutils background estimator (via astropy)";
netMF::usage="matrix factorization using NN architecture";



(* ::Subsection:: *)
(*clustering*)


(*pca\[Bullet]kmeans::usage="curried function for PCA/Kmeans clustering";*)
caCluster::usage="curried function for generalized component analysis and clustering";
clusterCenters::usage="curried function for extracting 1D cluster centers. Requires x coordinate and oout of ca\[Bullet]cluster";


(* ::Subsection:: *)
(*python functions into WL*)


pyF::usage = "Quick wrapper for a python function. use pyF[py]@'pythonstring'";
pyBlobs::usage = "Scikit's blob dog, doh and log functions channeled to WL";
pySciKit::usage ="Portal to scikits clustering and dimension reduction functionalities";


(* ::Subsection:: *)
(*image analysis functions*)


numPartitions::usage = "Find how many image partitions one will get from a given image";
meshGrid::usage = "Replicates numpy's meshgrid function";
bgSubtract::usage = "Subtract polynomial background. Returns NumericArray. Good for 
						direct plug into ImageAdjust@Image@Normal@#";
pyHistogram::usage = "numpy function for histogram. Not sure it's really faster";
diskRoiMask::usage = "create a disk matrix around a specific pixel in the image. Returns mask, that when flattened can be applied directly to hypespectral
data-set via Pick";


(* ::Subsection:: *)
(*1D analysis*)


removeSpikes::usage = "remove spikes from spectra with quantile regression";


(* ::Subsection:: *)
(*viz functions*)


tickScale::usage="rescale ticks after Show, using Show[plotHandle,Ticks->{tickScale[plotHandle,factor],Automatic}] for example";
ticks::usage="explicit definition of  and subticks. Insert in instead of Automatic into ticklabels";


(* ::Subsection:: *)
(*SMIM functions*)


loadSMIM::usage="load smim signals from h5 data files";
parseSMIM::usage="parse a SMIM-containing h5 file from Asylum as recorded by Stu";


(* ::Subsection:: *)
(*clustering functions*)


splitTrainValidate::usage = "split a list of data (any kind) into train/validate portions";


(* ::Subsection:: *)
(*h5 functionality*)


saveH5::usage = "export expression to hname file on specific path. Default overwrite";
recallH5::usage = "overloaded function to pull variables out of h5 files";
readH5saveSVG::usage = "overloaded function to pull figures and lists of figures from h5 files (dedicated!)
  and save them as svg in the same folder";


(* ::Section:: *)
(*Begin definitions*)


(* ::Code::Initialization::GrayLevel[0]:: *)
Begin["`Private`"];


\[Square]x_:=Map@@{x,#}&;
pipe = RightComposition;
reveal = GeneralUtilities`PrintDefinitions;


(* ::Section:: *)
(*Aux*)


growBranch[val_?(Not[AssociationQ@#]&), newkey_:"s", mod_:(#&)]:=<|newkey-> mod@val|>;
clearPlot[p_]:=Show[p,BaseStyle-> {FontFamily->"Latin Modern Roman",FontSize->14},AxesStyle-> Thickness[0.003]];
quickShape[arr_?ListQ,dims_?ListQ]:=ArrayReshape[arr,Join[dims,{Last@Dimensions@arr}]];
dimCheck[arr_?ListQ, d_]:=(Length@Dimensions@arr>=2);
adjustPlot[plot_Graphics,styles_List,op:OptionsPattern[Graphics]]:=Module[{x=styles},Show[MapAt[#/.{__,ln__Line}:>{Directive@Last[x=RotateLeft@x],ln}&,plot,1],op]];


tabbedNotebook[name_:"note1", tabs_:6, tabnames:"fig"] := Module[{n1},
        (Get["https://raw.githubusercontent.com/b3m2a1/mathematica-tools/master/NotebookTabbing.wl"];

        n1 = CreateDocument["Input"]; SetDockedTabs[n1, Table[tabnames <> ToString @ i -> i, {i, 3}]])
];


(* ::Section:: *)
(*Save/Retrieve notebook*)


SetAttributes[saveState,HoldAll];
saveState[saveFile_:NotebookFileName[] <>".mx"]:=Block[{},
	Export[saveFile,packVars[]];
	Echo["saved in " <> saveFile];
	]


SetAttributes[getState,HoldAll];
getState[saveFile_:NotebookFileName[] <>".mx"]:= Import[saveFile]//unPackVars



packVars[] := 
	Block[{names, kernAssc, keyFilter},
	(keyFilter[key_]:=
		If[
			StringMatchQ[ToString@Head@Symbol@key,"class"], (Symbol@key) . "save"[],
				If[ByteCount[Symbol@key]>1000, Symbol@key]
			];	
		
	kernAssc = AssociationMap[keyFilter@#&,  Names["Global`*"]];
	kernAssc["notebook"] = Compress@NotebookGet[]; (*get the whole notebook too*)
	kernAssc)
	]


unPackVars[assc_]:=
		Module[{keyFilter, arr},
		(keyFilter[key_,value_]:=
			If[
				And[AssociationQ[value],KeyExistsQ[value, "self"]], 
				(Sow["class " <> key];
				value["self","parent"][Echo@key, value["self"]]
				),
				ToExpression[Sow@key, InputForm,Function[name,name=value,HoldAll]]
			  ];
		
		Reap[KeyValueMap[keyFilter[#1,#2]&, assc]]//
			RightComposition[Last,Last,Sort,Multicolumn[#,5]&,TableForm]
		
			)
			]


unPackVars[assc_, specificKey_]:=
		Module[{keyFilter},
		(keyFilter[key_,value_]:=
			If[
				And[AssociationQ[value],KeyExistsQ[value, "self"]], 
				(Sow["class " <> key];
				value["self","parent"][Echo@key, value["self"]]
				),
				ToExpression[Sow@key, InputForm,Function[name,name=value,HoldAll]]
			  ];
		
		Reap[KeyValueMap[keyFilter[#1,#2]&, KeyTake[assc, specificKey]]]//
			RightComposition[Last,Last,Sort,Multicolumn[#,5]&,TableForm]
			)
			]


(* ::Section:: *)
(*Clustering*)


caCluster[data_][
		dimRedFunc_:(DimensionReduce[#]&), clusterFunc_:(ClusterClassify[#]&), pointSize_:0.005]:=
		Block[{ct=<||>,reducedDims, nClusters},
		(
		ct["params"]= <|"clusterFunc"-> clusterFunc, "dimRedFunc"-> dimRedFunc, "colors"-> (ColorData[24, "ColorList"][[#]]&/@{1,5,2,7,10})|>;
		ct["dimRed"] =  NumericArray@dimRedFunc@data;
		ct["trainedfunc"] = clusterFunc@Normal@ct["dimRed"];
		ct["labels"] = NumericArray@ct["trainedfunc"]@ct["dimRed"];
		reducedDims = Last@Dimensions@ct["dimRed"];
		nClusters = Echo@Max@ct["labels"];
		ct["scatter"] = If[reducedDims < 3,
		ListPlot[
			Style[Pick[Normal@ct["dimRed"], Normal@ct["labels"], #],Darker@ct["params"]["colors"][[#]], PointSize[pointSize]]&/@Range@nClusters,
			AxesLabel-> Table["C" <> ToString[j],{j,Range@nClusters}],PlotRange->Automatic,Axes->None],
			Echo@"need to extend plotting to 3D"];
			
		ct["map"]=
			DensityPlot[ct["trainedfunc"]@{x,y},
			{x,Min@ct["dimRed"],Max@ct["dimRed"]},{y,Min@ct["dimRed"],Max@ct["dimRed"]},
			Frame->None,ColorFunction->(Opacity[0.3,ct["params"]["colors"][[#]]]&),ColorFunctionScaling->False];
		ct
		)];



clusterCenters[ct_?AssociationQ, styleOpts_:Thickness[0.005]][data_, xx_,mod_:(#&),plotOpts_:plotStyle[]] :=
		Block[{},(
			ListLinePlot[
			Style[
			Transpose[{Normal@xx,
			mod[Mean[Pick[data,Normal@ct["labels"], #]]]}],ct["params"]["colors"][[#]], styleOpts
			]&/@Range@Max@ct["labels"],plotOpts]
			) 
			];


(* ::Section:: *)
(*FileIO*)


readDat[fname_]:=
	Block[{lst, datapos, assc,header, data, chanpos, chanposOffset, channelsNames},
		(
		lst = Import[fname];
		datapos = First@Flatten@Position[lst,"[DATA]"];
		header =lst[[1;;datapos]];
		data = lst[[ datapos+1;;]];
		chanpos = First@#&/@Position[StringPosition[data[[1]],"("~~__~~")"],{1,3}];
		chanposOffset = Join[{1},(chanpos + 1)[[1;;-2]]];
		channelsNames = MapThread[StringJoin@data[[1]][[#1;;#2]]&,{chanposOffset,chanpos}];
		assc = <|MapThread[#1-> #2&,{channelsNames,Transpose@data[[2;;]]}]|>;
		assc["Z"]= Last@Flatten@(Pick[#,ContainsAll[#,{"offset","Z"}]]&/@lst);
		assc
		)
		];


openNotebook[f_String] := If[StringContainsQ[f,"/"],
NotebookOpen[f],
NotebookOpen[NotebookDirectory[]<> f]]


(* ::Section:: *)
(*Nanonis*)


(* ::Subsection:: *)
(*reporting functionality*)


(*these need to be moved to HTML webpages too*)
reportCore[grd_?AssociationQ]:=
	Block[{attrs=grd["header"]},
	(attrs["bias"] = {Min@#, Max@#}&@grd["sweep_signal"];
	attrs["chanPlot"]= Grid[{{ListPlot[Transpose[{Normal@grd["sweep_signal"],#}]&/@#]&@RandomSample[Flatten[Normal@grd["Current (A)"],1],10],
	ImageAdjust@Image@bgSubtract@grd["topo"]}}];
	NiceGridDark@KeyDrop[attrs,
		{"num_parameters", "measure_delay","experiment_size","experimental_parameters","fixed_parameters"}])];

reportChans[grd_?AssociationQ]:=
	Block[{reportGrid},(
		reportGrid =KeyTake[grd,Complement[Keys@grd,{"params","Z (m)","sweep_signal", "header"}]];
		NiceGridDark@Partition[#,3]&@(If[#=="topo",
		Labeled[ImageAdjust@Image@bgSubtract@reportGrid[#],"topo",Top],
		MatrixPlot[Part[reportGrid[#],All,All,2],PlotLabel->#]]&/@Keys@reportGrid
	))];
(*Pick[Keys@reportGrid,Values@(Length@Dimensions@#&/@reportGrid),_?(#\[Equal]3&)]*)

reportGrid[gridFileName_?StringQ]:= 
	Block[{grd},
		(grd = OOP`parse3DS[gridFileName];
		Echo@reportCore[grd];
		grd)];

reportGrid[grd_?AssociationQ]:= reportCore[grd];

reportGrid[grd_?AssociationQ, chans_?IntegerQ]:=Block[{},
	(Echo@reportCore[grd];
	reportChans[grd])];


figToClip[f_, res_:200] := Echo@f//
							Export["t2.png",#,ImageResolution->res, Background-> None]&//
							Import//
							CopyToClipboard;


figToSVG[f_, fname_]:=  Echo@f//
				Export[NotebookDirectory[]<>fname<>".svg",#]&//
				CopyToClipboard;


figToPNG[f_, fname_]:=  Echo@f//
				Export[NotebookDirectory[]<>fname<>".png",#, ImageResolution->600,
				Background->None]&//
				CopyToClipboard;

figToPNG[f_, fname_, res_:600]:=  Echo@f//
				Export[NotebookDirectory[]<>fname<>".png",#, ImageResolution->res,
				Background->None]&//
				CopyToClipboard;

figToPNG[f_, fname_, op__:OptionsPattern]:=  Echo@f//
				Export[NotebookDirectory[]<>fname<>".png",#, op]&//
				CopyToClipboard;


(* ::Section:: *)
(*Spectra*)


normalize[chanNorm_:(#/1*^-12&)][data_] := NumericArray@Flatten[Normal@chanNorm@data,1];


denoise[dimReduceComponents_:3][data_]:=
	Block[{dimReducer},
		dimReducer=dimReducePacket[Normal@data,dimReduceComponents];
		NumericArray@dimReducer["ReducerFunction"][data,"ReconstructedData"]];


removeSpikes[data_,quantiles_:{0.05,0.95}, interp_:25]:=
		Block[{qfuncs, topOutliers, outlierRegions, newData, outlierWindows, intrp},
			(
			qfuncs=ResourceFunction["QuantileRegression"][data,interp,quantiles];
			topOutliers=Flatten@(Position[data,#]&/@Select[data,qfuncs[[-1]][#[[1]]]<0.7 #[[2]]&]);
			newData =Part[data,Complement[Range@Length@data,Flatten[#]&@(Join[Range[Max[{1,#-4}],Min[{#+4,Length@data}]]]&/@topOutliers)]];
			intrp =ListInterpolation[Sequence@@{Last@#,{First@#}}]&@Transpose@newData;
			Transpose[{#,intrp@#}]&@First@Transpose@data
			)];


(* ::Subsection:: *)
(*visualization*)


(* ::Subsubsection:: *)
(*plotStyle*)


plotStyle[framethick_:0.004] := 
	{
	BaseStyle->Directive[FontFamily->"Sansa",FontSize->18, FontColor->Darker@Gray], 
	Axes->False,
	PlotStyle->Directive[Thickness[2 framethick]], 
	Frame->True, 
	FrameStyle->Directive[ Thickness[framethick]],
	ImageSize->300,
	PlotRange->All, 
	AspectRatio->1.0, 
	GridLines->Automatic,
	GridLinesStyle->Directive[Gray, Thickness[framethick/10]]
	};


plotStylePhys[s_Symbol] := FilterRules[plotStyle[],Options[s]]


plotStylePhys[] := 
	Module[{specs},
	specs = FilterRules[plotStyle[],Options[#]]&/@Stack[];
	First@Pick[specs, specs//Map[Dimensions,#]&//Flatten, _?(#>0&)]
	]


plotStylePhys[xlabel_?StringQ, ylabel_?StringQ] := Join[plotStylePhys[], {FrameLabel->{xlabel,ylabel}}];


plotStylePhys[s_Symbol, xlabel_?StringQ, ylabel_?StringQ] := Join[plotStylePhys[s], {FrameLabel->{xlabel,ylabel}}];


addLabel[plot_,labels_:{"",""},op:OptionsPattern[]:{}]:=
Labeled[plot,{First@labels,Rotate[Last@labels,Pi/2]},{Bottom,Left},op,LabelStyle->{FontFamily->"Sansa",FontSize->17, FontColor-> Darker@Gray},Spacings->{0, 0} ];


(* ::Subsubsection:: *)
(*others*)


physicalTicks[src_,nticks_]:={#+1,(Round[src[[#+1]],0.001])}&/@Floor@Subdivide[Length@src-1,nticks-1];


tickScale[plotname_,factor_]:=Map[Times[#,{1,If[NumberQ[#[[2]]],1/factor,1],{1,1},{1,1}}]&,AbsoluteOptions[plotname,Ticks][[1,2,1]]]


ticks[min_,max_,step_:0.1,ticklabel_:(#&)]:=Table[If[ FractionalPart[i]==0.,{i,ticklabel@i,.02,Black},{i,"",.01,Black}],{i,Floor[min],Ceiling[max],step}]


customTicks[min_,max_,numMajor_,numMinor_:5,tickLengths_:{.02,.01}] :=Charting`ScaledTicks[{Identity,Identity},TicksLength->{.03,.01}][min,max,{numMajor,numMinor}]


singleSpectraViz[data_,chans_:{"cf"}]:=
				DynamicModule[{r={1,1}},
				Row@{Slider2D[Dynamic[r],{{1,1},#[[1;;2]]&@Dimensions@data[chans[[1]]],{1,1}},Appearance->{"Open"}],
				Dynamic@Row[ListLinePlot[Transpose@@{Normal@{data["bias"],data[#][[r[[1]],r[[2]]]]}},ImageSize->Medium]&/@chans]}]


singleSpectraMapper[data_,chans_:{"cf"}]:=
			Dynamic[Module[{im,xp,yp,mp},
			{
			im = ImageAdjust@Image[#,ImageSize->Medium]&@data["zf"][[;;,;;,128]];
			mp =Floor/@(If[TrueQ[#==None],{1,1},#]&@MousePosition[{"Graphics",Image},{1,1}]);
			Grid[{{Show[im,Graphics[{Red,PointSize[0.025],Point[Floor/@mp]}]], SpanFromLeft},
			Row[ListLinePlot[Transpose@@{Normal@{data["bias"],data[#][[mp[[1]],mp[[2]]]]}},ImageSize->Medium]&/@chans]
			}]
			}
			]]


(*This needs to be rewritten, so that data, chans and topo come in as already
data, not for reformatting inside the function*)

spectraPicker[data_?ListQ, topoData_?(dimCheck[#,2]&), xvec_:{}]:=
DynamicModule[{list=<|1->{}|>,lst,curGroup = 1, delpos,coordList, pickedPos, plotSpec,xv},
	Row@{
		EventHandler[
			Module[{ datum},
	coordList = Transpose[Flatten/@meshGrid[#1,#2]&@@Range/@Dimensions@#]&@topoData;
			xv =If[Length[xvec]==0,Range@Last@Dimensions@First@data,xvec];
				plotSpec[datum?ListQ,pickedPos_?ListQ,xx_]:=Transpose[{xx,datum[[Sequence@@#]]}]&/@pickedPos;
					Grid[{{
					Dynamic[Framed@Show[
								ImageAdjust@Image[#,ImageSize->Large]&@topoData,
								Graphics[{Red,Point[list@curGroup],
								EdgeForm[Directive[Thick,Dashed,Blue]],
								Transparent,Disk[#,2]&/@list[curGroup]},
								PlotRange->200]]],
					Dynamic[(
						Print[pickedPos];
						pickedPos =coordList[[#]]&/@Flatten[Nearest[coordList-> "Index",#]&/@list[curGroup]];
						Function[{d,pos},ListPlot[Transpose[{xv,Part[d,Sequence@@#]}]&/@pos]][#,pickedPos]&/@ data)]
						}}]],
(*this is picker for points within the image*)	
			
		{{"MouseClicked",1}:>{AppendTo[list[curGroup],MousePosition@"Graphics"],lst = list},
		{"MouseClicked",2}:>Module[{},{delpos =Nearest[list[curGroup]->"Index",MousePosition@"Graphics"], list[curGroup]=If[Length@list[curGroup]>0,Drop[list[curGroup],delpos],list[curGroup]],lst = list}]
		}
	]}]


meanSpectraPlot[data_?AssociationQ, chan_:{"cf"},subsample_:All,OptionsPattern[ListPlot]]:=
	Which[And@@(MemberQ[Keys@data,#]&/@chan),#]&@
		Module[{chanData,meanChanError},
			Row@{chanData = (#/Abs@Mean@Flatten@#)&@Part[Flatten[Normal@data[#],1],subsample]&/@chan;
				meanChanError = Around@@#&/@Transpose[{Mean@#,Sqrt@Variance@#}]&/@chanData;
				Row@(ListPlot[Transpose@{Normal@data["bias"],#[[2]]},ImageSize->Medium,
				AxesLabel->{"bias",Part@@{chan,#[[1]]}},
				PlotStyle->OptionValue[PlotStyle]]&/@MapIndexed[Append[#2,#1]&,#]&@meanChanError)}]
(*Alternative definition for averaging over the list*)

meanSpectraPlot[data_?ListQ, xaxis_:{}, op: OptionsPattern[Graphics]]:=
	Block[{meanChanError, xx},(
		xx=If[Length[xaxis]==0,Range@Last@Dimensions@data,xaxis];
		meanChanError = Around@@#&/@Transpose[{Mean@#,Sqrt@Variance@#}]&@data;
		ListLinePlot[Transpose@{xx,meanChanError},op]
	)]


chanHistogram[data_?AssociationQ, chan_:{"cf"}, bins_:30, mod_:(#&), op:OptionsPattern[DensityHistogram]]:=Which[And@@(MemberQ[Keys@data,#]&/@chan),#]&@
Module[{histDim, plotMod, histPlots},Row@{
	histDim = Transpose[{Normal@data["bias"],#}]&/@mod@Flatten[Normal@#,-2+Length@Dimensions@#]&@data[#]&/@chan;
	histPlots = DensityHistogram[Flatten[#,1],bins]&/@histDim;
	Row[Show[#,op]&/@histPlots]}]



histogram2D[bins_:30,op: OptionsPattern[DensityHistogram]][xvec_:{}][data_?ListQ] :=
Module[{histDim, plotMod, histPlots,xx},(
		xx = If[Length[xvec]==0,Range@Last@Dimensions@data,xvec];
		histDim = Flatten[Normal@#,-2+Length@Dimensions@#]&@data;
		histDim = Transpose[{xx,#}]&/@histDim;
		histPlots = DensityHistogram[Flatten[histDim,1],bins, op]
		)]



(* ::Section:: *)
(*FFT*)


(* ::Code::Initialization::GrayLevel[0]:: *)
fftshift[dat_?ArrayQ,k:(_Integer?Positive|All):All]:=Module[{dims=Dimensions[dat]},RotateRight[dat,If[k===All,Quotient[dims,2],Quotient[dims[[k]],2] UnitVector@@{Length[dims],k}]]];


(* ::Code::Initialization::GrayLevel[0]:: *)
ifftshift[dat_?ArrayQ,k:(_Integer?Positive|All):All]:=Module[{dims=Dimensions[dat]},RotateRight[dat,If[k===All,Ceiling[dims/2],Ceiling[dims[[k]]/2] UnitVector@@{Length[dims],k}]]];


(* ::Code::Initialization::GrayLevel[0]:: *)
imageCenter[im_?ImageQ] := Floor@Dimensions@ImageData@im/2.;


(* ::Code::Initialization::GrayLevel[0]:: *)
hannWindow[im_?ArrayQ] := Block[{w,h,hg,wg}, {w,h} = Dimensions@im; {hg, wg} = meshGrid[Range[h],Range[w]]; 
									Times[HannWindow[hg/h-0.5],HannWindow[wg/w-0.5]]];


(* ::Code::Initialization::GrayLevel[0]:: *)
plotRanger[im_,nsigma_:2]:={#1-#2,#1+#2}&@@{Mean@#,nsigma* StandardDeviation@#}&@Flatten@im;


(* ::Code::Initialization::GrayLevel[0]:: *)
bandPass[im_?ArrayQ,d1_?IntegerQ,d2_?IntegerQ]:=Module[{imInternal, mask, imfft, imfiltered, imfftMasked, imMod},
imInternal = Part[im,Range@#,Range@#]&@Min@Dimensions@im;
(*assure square array*)
mask = DiskMatrix[Max[#1]+1,Length@#2]-DiskMatrix[Min[#1],Length@#2]&@@{{d1,d2},imInternal};
imfft=fftshift@Fourier@imInternal;
imfftMasked = imfft*mask;
imfiltered =InverseFourier@ifftshift@(imfftMasked);
imMod = (#//Abs[1+#]&//Log//Image//ImageAdjust//DynamicImage)&;
Echo@Grid[{{imMod@imfftMasked, imMod@imfiltered}}];
Return[imfiltered,Module];
];


(* ::Code::Initialization::GrayLevel[0]:: *)
bedOfNails[xp_,yp_,sz_]:=SparseArray@Flatten@Table[{xp*i,yp*k}->1,{i,1,sz/xp},{k,1,sz/yp}];


(* ::Code::Initialization::GrayLevel[0]:: *)
showFFT[im_?ArrayQ] := ImageAdjust@Image@Raster[#,ColorFunction->"Cool"]&@Log[#+1]&@Abs@fftshift@Fourier@im;


(* ::Code::Initialization::GrayLevel[0]:: *)
baseFFT[im_?ArrayQ] :=  Block[{hw,imC},
					imC = (NumericArray@#)*(NumericArray@HannWindow@#)&@im;
					Abs@fftshift@Fourier@Normal@imC];


(* ::Code::Initialization::GrayLevel[0]:: *)
numPartitions[im_?ArrayQ, pWidth_?ListQ, pStride_?ListQ] := Floor[(Dimensions[im][[#]]-pWidth[[#]])/pStride[[#]] +1]&/@Range@Length@Dimensions@im ;


(* ::Code::Initialization::GrayLevel[0]:: *)
meshgrid[x__?VectorQ] := Transpose[Reverse[Transpose[Tuples[Reverse[{x}]]]]]


(* ::Section:: *)
(*Matrix factorization*)


netMF[data_,ncomps_, trainingTime_:2.]:=
Module[{nmfLayerNoBias, net,netTrained, W, H, dimX=Last@Dimensions@data, enc},
{

nmfLayerNoBias[inputDim_, outputDim_] :=FunctionLayer[Dot[#Input, Abs@NetArray[<|"Name"-> "Weights", "Dimensions"-> {inputDim,outputDim}|>]]&];

net = NetGraph[{Ramp,50,Tanh ,ncomps,nmfLayerNoBias[ncomps,dimX],MeanSquaredLossLayer[]},{1 -> 2 -> 3 -> 4 -> 5  ->  NetPort["Output"],5 -> NetPort[6, "Input"], NetPort["Input"] -> NetPort[6, "Target"]},  "Input" -> dimX,"Output" -> dimX  ];

netTrained = NetTrain[net, <|"Input" -> Normal@data|>, LossFunction -> "Loss",
TrainingProgressReporting->None, ValidationSet->Scaled[0.2], TimeGoal->trainingTime];

enc = netTrained//
Take[#,{NetPort["Input"],NetPort["Output"]}]&//
Take[netTrained,{NetPort["Input"],4}]&;
W = enc@data;
H = NetExtract[netTrained,5]//Normal//#Net&//Normal//First//Normal//#Array&//Abs//Normal;
Return[<|"W"-> NumericArray@W, "H"-> NumericArray@H|>, Module];
}
]


(* ::Section:: *)
(*Pythonic functions*)


pyF[py_] := ExternalEvaluate[py, #]&;


pyBlobs[py_]:=ExternalEvaluate[py,"from skimage.feature import blob_log, blob_dog, blob_doh"];


findBlobs[py_][im_]:=
(pyBlobs[py];
Manipulate[
	Module[{dims, blobs},
	{
	dims = Dimensions@im;
	blobs ={#[[2]],Dimensions[im][[2]]-#[[1]],#[[3]]}&/@Normal@ExternalFunction[py,"blob_log"][im, minS,maxS, nS, tS, oL, True];
	Show[{Sharpen[#,5]&@ImageAdjust@Image@im,Graphics[{Orange,Disk[{#[[1]],#[[2]]},2.]}&/@blobs]}]
	}],
{{minS, 2.5},0.5,10,0.5},
{{maxS,6.},0.5,10,0.5},
{{nS,10.},0.5,20,0.5}, 
{{tS,0.4},0.01,1.0,0.01},
{{oL,0.55},0.05,1.0,0.05}])


pySciKit[py_]:=
<|
"Blobs" -> Module[{},
	ExternalEvaluate[py,"from skimage.feature import blob_log, blob_dog, blob_doh"];
	<|"blobLog"-> ExternalFunction[py, "lambda im, min_s=1, max_s=30, n_s=10, ts=0.1, o_l=0.5, l_s=False, e_b=True:
			blob_log(im, min_sigma=min_s,max_sigma=max_s,num_sigma=n_s,threshold=ts,overlap=o_l,log_scale=l_s,exclude_border=e_b)"],
	"blobDog"-> ExternalFunction[py, "lambda im, min_s=2, max_s=10, s_r = 1.6, t_s=0.1, o_l=0.5,e_b=False: 
			blob_dog(im, min_sigma=min_s,max_sigma=max_s,sigma_ratio=s_r,threshold=t_s,overlap=o_l,exclude_border=e_b)"],
	"blobDoh"-> ExternalFunction[py, "lambda im, min_s=2, max_s=10, n_s = 10, t_s=0.01, o_l=0.5,l_s=False: 
			blob_doh(im, min_sigma=min_s,max_sigma=max_s,num_sigma=n_s,threshold=t_s,overlap=o_l,log_scale=l_s)"]|>],
		
"Manifold" -> Module[{},
	ExternalEvaluate[py,"from sklearn import manifold"];
	<|"tSNE"-> ExternalFunction[py, "lambda X, n_components=2, perplexity=5, n_iter=1000, init='random', random_state=0: manifold.TSNE(n_components=n_components, init=init,
                         random_state=random_state, perplexity=perplexity, n_iter=n_iter).fit_transform(X)"]|>
                         ],
                         
"Datasets" -> Module[{},
	ExternalEvaluate[py,"from sklearn import datasets"];
		<|"blobs"-> ExternalFunction[py, "lambda n_samples=2, n_features=2, centers=None, cluster_std=1.0: datasets.make_blobs(n_samples=n_samples, n_features=n_features, centers=centers, cluster_std=cluster_std, shuffle=True)"]|>
         ]         
|>


pyHistogram[py_]:=Module[{},
ExternalEvaluate[py,"from numpy import histogram"];
ExternalFunction[py,"lambda a, bins=10,range=None,normed=None,weights=None,density=None: histogram(a,bins=10,range=None,normed=None,weights=None,density=None)"]]


nmfPY[X_, ncomps_:2]:=
Module[{py, nmfs},
(
py = StartExternalSession["Python"];
(*init*)
ExternalEvaluate[py,"

import numpy as np
def assignme(name,var):
	globals()[name] = var;

import matplotlib;
matplotlib.use('TkAgg');
from matplotlib import pyplot as plt

from sklearn.decomposition import NMF
"];

ExternalEvaluate[py,"assignme"]["X",NumericArray@X];
ExternalEvaluate[py,"assignme"]["ncomps",ncomps];

ExternalEvaluate[py,"
model=NMF(n_components=ncomps,init='random',random_state=0)
W=model.fit_transform(X)
H=model.components_
"];
nmfs =ExternalEvaluate[py,"{'W':W,'H':H}"];

Return[nmfs,Module];
DeleteObject[py];
)
];


kpcaPY[X_, ncomps_:2, kernel_:"linear"]:=
Module[{py, nmfs},
(
py = StartExternalSession["Python"];
(*init*)
ExternalEvaluate[py,"

import numpy as np
def assignme(name,var):
	globals()[name] = var;
from sklearn.decomposition import KernelPCA
"];
Map[ExternalEvaluate[py,"assignme"]@@Sequence@#&,
{{"X",NumericArray@X},
{"ncomps",ncomps},
{"ker",kernel}}];

ExternalEvaluate[py,"
transformer = KernelPCA(n_components=ncomps, kernel=ker)
X_transformed = transformer.fit_transform(X)
"];

Return[ExternalEvaluate[py,"X_transformed"],Module];
DeleteObject[py];
)
];


pyBgEstimate[X_, window_:{50,50}, filterSize_:{2,2}]:=
Module[{py},
(
py = StartExternalSession["Python"];
(*init*)

ExternalEvaluate[py,"
import numpy as np
from astropy.stats import SigmaClip
from photutils.background import Background2D, MeanBackground, MedianBackground
def assignme(name,var):
	globals()[name] = var;
"];

Map[ExternalEvaluate[py,"assignme"]@@Sequence@#&,
{{"X",NumericArray@X},
{"window",window},
{"filter_size",filterSize}}];

ExternalEvaluate[py,"
sigma_clip = SigmaClip(sigma=3.0)
bkg_estimator = MedianBackground();
bkg_median = Background2D(X, window, filter_size=filter_size, sigma_clip=sigma_clip, bkg_estimator=bkg_estimator);
bkg_estimator = MeanBackground();
bkg_mean = Background2D(X, window, filter_size=filter_size, sigma_clip=sigma_clip, bkg_estimator=bkg_estimator);
"];

Return[ExternalEvaluate[py,"{'mean':bkg_mean.background,'median':bkg_median.background}"],Module];
DeleteObject[py];
)
];


(* ::Section:: *)
(*Images*)


(* ::Subsection:: *)
(*image visualization*)


colorbar[
	{min_,max_},
	colorFunction_: Automatic,
	divs_: 150]:=
	(*FrameLabel\[Rule]{{None,Row[{Subscript["t","esc"]}]},{None,None}},LabelStyle\[Rule]Directive[FontFamily\[Rule]"Helvetica",20] <- Use this to label the scalebar*)
	DensityPlot[y,{x,0,0.1},{y,min,max},AspectRatio->20,PlotRangePadding->0,PlotPoints->{2,divs},
	MaxRecursion->0,Frame->True,FrameTicks->{{None,All},{None,None}},FrameTicksStyle->Directive[FontFamily->"Helvetica",40,Plain],ColorFunction->colorFunction];


(*imageScalebar[imData_,calibration_,cf_:"GrayYellowTones", scaleColor_:White, sprinkles_:Nothing,opts:OptionsPattern[MatrixPlot]]:=
	(*calibrartion = First@Dimensions@scaledData/scanRange[[1]]*)
	Block[{scaledData,scaleBarValue, scaleBarPixels, scaleBar, imPlot, imPlotScale, min, max},
		(
	scaledData = Rescale[Normal@imData];
		{min,max}= {Min@#,Max@#}&@Flatten@Flatten@scaledData;
		scaleBarValue = 0.2 First@Dimensions@imData/calibration//Floor//IntegerPart;
		scaleBarPixels = calibration*scaleBarValue//Floor;
		
		scaleBar = {Text[Style[ToString@scaleBarValue <> " nm",scaleColor,25],
{70,75}],{scaleColor,AbsoluteThickness[5],Line[{{20,50},{20+scaleBarPixels,50}}]}};
		imPlot = MatrixPlot[scaledData, Frame -> None,PlotRange -> All, ColorFunctionScaling->False,
			ColorFunction -> (ColorData[cf][Rescale[#,{1.1*min,0.9*max}]]&)];
		imPlot = Show[{imPlot, sprinkles}];
		imPlotScale = Graphics[scaleBar,PlotRange->Transpose@{{0,0},Dimensions@imData},Prolog-> {Inset[imPlot,Center,Center,Dimensions@imData]}];
		Row[{
			Show[imPlotScale, opts],
			Show[colorbar[{min,max},cf,150],opts]
			}]
	)];*)


imageScalebar[imData_,calibration_,cf_:"GrayYellowTones", scaleColor_:White, modifier_:(#&)]:=
	(*calibrartion = First@Dimensions@scaledData/scanRange[[1]]*)
	Block[{scaledData,scaleBarValue, scaleBarPixels, scaleBar, imPlot, imPlotScale, min, max},
		(
	scaledData = Rescale[Normal@imData];
		{min,max}= {Min@#,Max@#}&@Flatten@Flatten@scaledData;
		scaleBarValue = 0.2 First@Dimensions@imData/calibration//Floor//IntegerPart;
		scaleBarPixels = calibration*scaleBarValue//Floor;
		
		scaleBar = {Text[Style[ToString@scaleBarValue <> " nm",scaleColor,25],
{70,75}],{scaleColor,AbsoluteThickness[5],Line[{{20,50},{20+scaleBarPixels,50}}]}};
		imPlot = MatrixPlot[scaledData, Frame -> None,PlotRange -> All, ColorFunctionScaling->False,
			ColorFunction -> (ColorData[cf][Rescale[#,{1.1*min,0.9*max}]]&)];
		imPlot =modifier@imPlot;
		imPlotScale = Graphics[scaleBar,PlotRange->Transpose@{{0,0},Dimensions@imData},Prolog-> {Inset[imPlot,Center,Center,Dimensions@imData]}, ImageMargins->1];
		GraphicsRow[{
			Show[imPlotScale],
			Show[colorbar[{min,max},cf,150]]
			}]
	)];


niceMatrixPlot[clrs_:"TemperatureMap",op:OptionsPattern[MatrixPlot]][data_]:=
	Block[{min, max},
		(
		{min,max}={Min@#,Max@#}&@Flatten@Flatten@data;
		MatrixPlot[data, ColorFunctionScaling->False,
			ColorFunction -> (ColorData[clrs][Rescale[#,{min,max}]]&), op]
		)];


diskRoiMask[srcImage_,diskXY_?ListQ, diskRadius_?NumberQ]:=
	Block[{xs,ys,dims,radius,mask},
		(
		dims=Dimensions@srcImage;
		ys=Array[N[#1]&,dims]-diskXY[[1]];
		xs=Array[N[#2]&,dims]-diskXY[[2]];
		radius=Sqrt[xs^2+ys^2];
		mask=UnitStep[diskRadius-radius]
		)];


(*we want to just get the points out, and then use highlight image for overlays*)
logBlob[im_,\[Sigma]log :_?ListQ : {5,5}, thresh_:0.2, meanShiftRange_:5]:=
Block[{logimage, maxima,masks,pts,fig},
(
logimage= im//Rescale//Image[LaplacianGaussianFilter[#,\[Sigma]log]*-(First@\[Sigma]log)^2]&;
maxima=ImageMultiply[MaxDetect[logimage],Binarize[logimage,thresh]];
pts = maxima;
pts = ComponentMeasurements[maxima,"Centroid"][[All,2]];
pts = Union[MeanShift[pts, meanShiftRange, MaxIterations -> 10]];
fig = Show[
		{Sharpen[#,1]&@ImageAdjust@Image[#]&@Rescale@im,
		Graphics[{Red,Opacity[1.0],Disk[{#[[1]],#[[2]]},1*Mean@ImageDimensions@logimage/300.]}&/@pts]}
		];
 masks = ComponentMeasurements[Binarize[logimage,thresh],"Mask"];
 <|"centroids"-> pts, "mask"->masks, "image"->fig |>
)]


(*logBlob[im_,\[Sigma]log :_?ListQ : {5,5}, thresh_:0.2, meanShiftRange_:5][op:OptionsPattern[Image]]:=
Block[{pts, fig},
(
pts =logBlob[im, \[Sigma]log, thresh, meanShiftRange][];
fig = Echo@Show[{Sharpen[#,1]&@ImageAdjust@Image[#,op]&@Rescale@im,Graphics[{Orange,Disk[{#[[1]],#[[2]]},2.]}&/@pts]}]
Return[pts,Block];
)]*)


(*logBlob[im_,\[Sigma]log :_?ListQ : {5,5}, thresh_:0.2, meanShiftRange_:5,showNNs_?NumberQ, calibration_:1][op:OptionsPattern[Image]]:=
Block[{pts, distGraph, fig, dist, ptsImage},
(
pts =logBlob[im, \[Sigma]log, thresh, meanShiftRange][];
dist = pts//NearestNeighborGraph[#,showNNs]&//EdgeList//#-> (NumberForm[calibration*#,2]&@EuclideanDistance[First@#,Last@#])&/@#&;
ptsImage = pts//Graphics[{Orange,Disk[{#[[1]],#[[2]]},1.]}&/@#]&;
distGraph = pts//NearestNeighborGraph[#,showNNs,EdgeLabels->dist, PlotTheme->"Scientific",VertexLabels->None]&;
fig = Show[{Sharpen[#,1]&@ImageAdjust@Image[#,op]&@Rescale@im,distGraph, ptsImage}]
)]
*)



logBlobMask[im_,\[Sigma]log :_?ListQ : {5,5}, thresh_:0.2, meanShiftRange_:5][op:OptionsPattern[Image]]:=
Block[{logimage, maxima,pts,fig},
(
logimage= im//Rescale//Image[LaplacianGaussianFilter[#,\[Sigma]log]*-(First@\[Sigma]log)^2]&;
maxima=ImageMultiply[MaxDetect[logimage],Binarize[logimage,thresh]];
pts = maxima;
pts = ComponentMeasurements[maxima,"Centroid"][[All,2]];
pts = Union[MeanShift[pts, meanShiftRange, MaxIterations -> 10]];
fig = Echo@Show[{Sharpen[#,1]&@ImageAdjust@Image[#,op]&@Rescale@im,Graphics[{Orange,Disk[{#[[1]],#[[2]]},2.]}&/@pts]}];
 masks = ComponentMeasurements[Binarize[logimage,thresh],"Mask"]
)]



logBlobScaler[im_Image, scaleRange_:Range[.5,50.,.5], binarizeScale_:0.1]:=
Module[{ scales},
scales = Flatten@Table[
im//
LaplacianGaussianFilter[#,logParm]&//
ImageData//
Rescale//
Image//
Binarize[#]&//
ComponentMeasurements[#,"Centroid", #Area>.5&]&//
Dimensions@#&,{logParm,scaleRange}];
Echo@ListLinePlot[Transpose[{scaleRange,scales}],PlotRange->All, ScalingFunctions->"Log", plotStylePhys["scale, arb. u.","connected components"]];
scales
]


(* ::Subsection:: *)
(*Fitting*)


fitFunc1D[blocks_?ListQ,data_?ListQ]:=
(* Example of blocks: 
xvariable should be xx. "func" is the derisred fitting functions, "constr" \[Rule] constraints; "guess" \[Rule] initial parameter guesses
{<|"func"\[Rule] {mc1 PDF[NormalDistribution[ma1,mb1],xx]}, "constr"\[Rule] {mc1>0, ma1<0.}, "guess"\[Rule] {{mc1,2.},{ma1,-1.},{mb1,1.}}|>,
<|"func"\[Rule] {mc2 PDF[NormalDistribution[ma2,mb2],xx]}, "constr"\[Rule] {mc2>0, ma2>0.}, "guess"\[Rule] {{mc2,2.},{ma2,1.},{mb2,1.}}|>}
data \[Rule] same as standard, list of {{Subscript[x, i],Subscript[y, i]}}
*)
Block[{fitAssc},
	(fitAssc = Merge[blocks,Flatten[#,1]&];
	NonlinearModelFit[data,Join[List@Total@fitAssc["func"],fitAssc["constr"]],fitAssc["guess"],x2])];


(* ::Subsubsection:: *)
(*Clustering functions*)


splitTrainValidate[dataArray_?ArrayQ,ratio_]:=Module[{train, validate},train = RandomSample[dataArray, Floor[ratio*Length@dataArray]];
validate=Complement[dataArray,train]; {train, validate}];


pcaScree[data_?ListQ,trunc_:All, opts:OptionsPattern[ListPlot]]:=
	Block[{v},
		v=Eigenvalues[Covariance[data]];
		Row[{ListPlot[100 Normalize[#,Total],PlotRange->All,AxesLabel->{"eigval","% variance"},ImageSize->Medium, opts],
		ListPlot[Normalize[100 Accumulate[#],Last],PlotRange->All,AxesLabel->{"eigval","cumul. % variance"},ImageSize->Medium, opts]}]&@v[[1;;trunc]]
		];

(*pcaScree[data_?(Not[ListQ@#]&),trunc_:All]:=data;
*)



dimReducePacket[data_,comps_:4]:=Block[{assc={}, props={"ReducerFunction","ReducedVectors"}},{
assc= DimensionReduction[data,comps,#]&@props;
Return[Association@MapThread[(#1->#2)&,{props,assc}],Block];}]


getLargestClusters[data_, csMethod_:(ClusterClassify[#,20,Method->"Agglomerate"]&), mod_:(#&)]:=
(*Use pattern: plotComponents[plztResponse,3] *)
Module[{classifier, labels,clusterPos, largeClusterData, largePos},
(*dimension reduction needs to be done externally reduce dimensions using automatic choice*)

classifier = csMethod@mod@data; (* obtain classifier within reduced dimensions using default or custom classifier function *)
labels = classifier/@mod@data; (*apply classifier to get the actual clusters *)

(*clusterPos = Table[Flatten@Position[cd, _?(#==l&)],{l,Range@Information[classify,"Classes"][[-1]]}];  (*get cluster positions in the array *)
*)
largePos = Select@@{clusterPos,Length@#>20&}; (*select clusters with more than 20 members per class*)
largeClusterData =Part[data,#]&/@largePos; (*pack data from within large (and assumed therefore significant) clusters*)
<|"dimReduce"-> dimReduce, "largePos"->  largePos, "largeClusterData"-> largeClusterData|> 
(*return association with the clustered data, indices and the dimensionality reduce function*)
]


pointsToHistogram3D[points_,OptionsPattern[ListDensityPlot3D]]:=Block[{ranges,bins,binCounts,transposedBinCounts},ranges=Round[CoordinateBounds[points]];
bins=Append[#,(0.03*(Max@#-Min@#))]&/@ranges;
binCounts=BinCounts[points,Sequence@@bins];
transposedBinCounts=Reverse[Transpose[binCounts,{3,2,1}],{1,2}];
ListDensityPlot3D[#,ColorFunction->"TemperatureMap",PlotLegends->Automatic,OpacityFunction->((2 #)&),ViewPoint->OptionValue[ViewPoint]]&@transposedBinCounts
]



hierarchy[data_?NumericArrayQ, trunc_:{1,Infinity}]:=Module[
{logDm,newDm,ub,res=<||>},
{
Needs["HierarchicalClustering`"];
(*agglomerate with defulat default distance function*)
ub = Echo@If[MatchQ[#,Infinity],Length@data,#]&@Last@trunc;
res["hCluster"] = HierarchicalClustering`DirectAgglomerate[System`DistanceMatrix[Normal@data],Range@Length@data];
res["hClusterIndices"]=(If[MatchQ[Head@#, HierarchicalClustering`Cluster],HierarchicalClustering`ClusterFlatten[#],#]&/@HierarchicalClustering`ClusterSplit[res["hCluster"],ub]);
Return[res,Module];
}];

hierarchy[distanceMatrix_?SymmetricMatrixQ, trunc_:{1,Infinity}]:=Module[
(*Assumes it's distance matrix on the entry*)
{logDm,newDm,ub,res=<||>},
{
(*agglomerate with defulat default distance function*)
ub = Echo@If[MatchQ[#,Infinity],Length@distanceMatrix,#]&@Last@trunc;
res["hCluster"] = HierarchicalClustering`DirectAgglomerate[distanceMatrix,Range@Length@distanceMatrix];
res["hClusterIndices"]=(If[MatchQ[Head@#, HierarchicalClustering`Cluster],HierarchicalClustering`ClusterFlatten[#],#]&/@HierarchicalClustering`ClusterSplit[res["hCluster"],ub]);
Return[res,Module];
}];


hierarchyPlots[res_, trunc_:{1,Infinity},opts:OptionsPattern[ListPlot]]:=Block[{dp,mp,hp},
(
(*plot results of hierarchy agglomerate with logarithm of default distance function*)
dp = HierarchicalClustering`DendrogramPlot[res["hCluster"],
HierarchicalClustering`TruncateDendrogram->trunc,Axes->{False,True},
AxesOrigin->{-1,Automatic},HierarchicalClustering`LeafLabels->(Length[{#}]&),opts]
)];


distMatrixHistogram[data_,bins_:100,mod_:(Log[#+1]&),OptionsPattern[Histogram]]:=Block[{dmExt},{
dmExt = DistanceMatrix[data];
Echo@Mean@Flatten@dmExt;
Histogram[Flatten@mod@dmExt,bins,"Probability"]}]


outliersAndClusters[hCluster_, splitLevel_]:=Module[{outliers= {},
residualClusters = {}},{
If[MatchQ[Length@#,0],AppendTo[outliers,#],AppendTo[residualClusters,#]]&/@HierarchicalClustering`ClusterSplit[hCluster,splitLevel];
Return[<|"outliers"->outliers,"residualClusters"->residualClusters|>,Module]
}]


plotClusters[clusteredData_,func_:(#&)] := 
Module[{csData,newCenters, newCenterImages},
(*csData=func/@#&/@clusteredData;*)
newCenters =Mean/@clusteredData@"largeClusterData";
newCenterImages = ArrayReshape[#,{11,64}]&/@newCenters;
GraphicsGrid[{MapThread[ plotArrayLabeledResponse[#1,#2]&,{#,Range@Length@#}]&@newCenterImages,
Histogram[Flatten@#,{-1,1,0.01},"Probability"]&/@func[csData]},Spacings->1,AspectRatio->1/3.5,ImageSize->{700,300}]
]


plotClusters1D[data_,clusterIndices_,OptionsPattern[ListLinePlot]]:=Module[{colors, clusteredData,meanVals, stdVals,pDat},
clusteredData = (Part[data,#]&/@#&/@clusterIndices);
meanVals = Flatten[#,1]&/@Mean/@clusteredData;
stdVals = Flatten[#,1]&/@(If[Length@#>1,Variance@#,0*#]&/@clusteredData);
pDat =MapThread[Transpose[{#1,#2}]&,{meanVals, stdVals}];
ListLinePlot[Around@@@#&/@pDat,PlotRange->OptionValue[PlotRange],AspectRatio->OptionValue[AspectRatio],PlotLegends->Placed[#,Right]&@(ToString[#]&/@(Length/@clusteredData))]
]


(* ::Section:: *)
(*SMIM*)


loadSMIM[h5file_]:=
<|"bias" ->  Flatten@Import[h5file,{"Datasets","/Measurement_000/Channel_000/Spectroscopic_Values"}],
"chan1"-> Import[h5file,{"Datasets","/Measurement_000/Channel_001/Raw_Data"}],
"chan0" -> Import[h5file,{"Datasets","/Measurement_000/Channel_000/Raw_Data"}]|>;

parseSMIM[phaseOffset_:1.53311,window_:52][dAssc_?AssociationQ]:=Block[{datum, stack=<||>, makeStack, plotStack, parseSwitchingSpec},(

makeStack[data_, chan_:"G"] := 
	Block[{st},
	data//
	{#["x"]["waves"],TakeList[#[chan]["rot"],Flatten@(Dimensions/@#["x"]["waves"])]}&//{First@#,(#-Mean@#)&/@Last@#}&//
	#[[All,3;;]]&//
	MapThread[Transpose[{#1,#2}]&,#]&
	];

plotStack[stk_,chan_:"C", op:OptionsPattern[ListLinePlot]]:=
	Block[{vvec,yerror},(
		vvec =(First@Transpose[#]&/@stk)//First;
		yerror = (Last@Transpose[#]&/@stk)//{Mean@#,StandardDeviation@#}&//MapThread[Around[#1,#2]&,#]&;
		Echo@ListLinePlot[Transpose[{vvec,yerror}], plotStylePhys["bias, V","\[CapitalDelta]smim" <>chan<>", arb. u."]];
		Transpose[{vvec,yerror}]
		)
	];

parseSwitchingSpec[data_,bias_]:=
(*data would be chan1[[index]]*)
	Block[{smimC=<||>, smimG=<||>,waves, x=<||>,splitSMIMvector},
		(
		x["src"] = Flatten@bias;
		smimC["src"] = BlockMap[Mean,(#["r"]&/@data),window]; 
		smimG["src"] = BlockMap[Mean,(#["i"]&/@data),window];
		
		{smimG["rot"],smimC["rot"]} = Transpose[RotationTransform[phaseOffset][Transpose[{smimC["src"],smimG["src"]}]]];
		x["waves"] = Partition[#,Length@#/(Length@FindPeaks@#-1)]&@bias;
		splitSMIMvector[vec_] := Mean[(#-#[[1]])&/@#[[5;;]]&@TakeList[vec,Length/@x["waves"]]];
		{smimC["mean"],smimG["mean"],x["mean"]} =splitSMIMvector/@{smimC["rot"],smimG["rot"],x["src"]};
		<|"C"->1000 smimC,"G"-> 1000 smimG,"x"->x|>
	)];


datum= parseSwitchingSpec[#,dAssc@"bias"]&/@dAssc@"chan1";
stack["G"] = datum//makeStack[#, "G"]&/@#&//Flatten[#,1]&;
stack["C"] = datum//makeStack[#, "C"]&/@#&//Flatten[#,1]&;
stack["plots"] = plotStack[stack[#],#]&/@{"G","C"};
stack
)];



(* ::Section:: *)
(*External functions*)


(* ::Input:: *)
(**)


Scan[SetAttributes[#, {Protected, ReadProtected}]&,
     Select[Symbol /@ Names["Trankvility`*"], Head[#] === Symbol &]];


End[];


Protect["Trankvility`*"];


EndPackage[]


(* ::Subtitle:: *)
(**)
