(* ::Package:: *)

(* ::Code::Initialization::GrayLevel[0]:: *)
BeginPackage["Calme`"];


(* ::Code::Initialization::GrayLevel[0]:: *)
Unprotect["Calme`*"];
ClearAll["Calme`*"];
ClearAll["Calme`Private`*"];


(* ::Subsection:: *)
(*a few init functions before the definitions to run on startup*)


NiceGrid := ResourceFunction["NiceGrid"]


(* ::Code::Initialization::GrayLevel[0]:: *)
fftshift::usage = "Center Fourier transform (phase-preserving)";
ifftshift::usage = "Uncenter Fourier transform (phase-preserving)";
imageCenter::usage = "Return coordinates of image center";
hannWindow::usage = "Return 2D Hann window (useful for FFT)";
plotRanger::usage = "Automatically adjust contrast within nsigma deviations of the mean";
bandPass::usage = "Interactive Fourier band pass filter";
bedOfNails::usage = "Bed of nails function with xp, yp -> spacings, and sz -> size";
showFFT::usage = "Quick! Show me fftshifted FFT magnitude";
randomCheck::usage = "Is this still alive?";
baseFFT::usage = "FFT amplitude with default Hann window filtering";
parse3DS::usage = "eke out 3ds into WL. Funnel bias and channels into association";
parseSXM::usage = "eke out sxm into WL. Funnel channels into association";
JsonImport::usage="ZImport[\"file.json\"] will import a compressed Mathematica expression from file.json.";
JsonExport::usage="ZExport[\"file.json\", data] will export data as a compressed Mathematica expression to file.json.";
todaysDate::usage="returns 2019-01-01 type of string";
saveDump::usage = "buttons to push and save kernel";
initNB::usage="commands to initate styling and other features in the notebook";
singleSpectraViz::usage="pick and look and spectra with a 2D slider";
singleSpectraMapper::usage="pick and look and spectra with a z-image of the soiurce area";
spectraPicker::usage="pick spectra by point and click witn a mouse";
meanSpectraPlot::usage="plot average curve with errorbars from hypespectral data, containing 'bias' vs some X";
getLargestClusters::usage="do a sequence of dimensionality reduction and clustering. Prospectively needs to be a monad";
plotClusters::usage="plot Clusters generated by getClusteredData";
plotClusters1D::usage="plot clusters of 1D data with errorbars. So far tested on Hierarchical clustering";
chanHistogram::usage = "plot histograms of hypespectral arrays. 'bias' channel or its analogue should
be specified";
pointsToHistogram3D::usage="convert point cloud to 3D histogram";
figureToClipboard::usage = "put figure into Clipboard. Saved via png";
hierarchy::usage="hierarchical clustering, returning cluster object and its stats down to 'truncate' levels";
pcaScree::usage="PCA scree plots, fractional and cumulative";
hierarchyPlots::usage="returns Dendrogram plot with log Distance, leaf labels corresponding to number of members in the cluster and clusters
with truncation";
outliersAndClusters::usage="split Cluster object into outliers and residual clusters. Length of residual clusters can be gained from #[[-2]] for each elemetn";
chainAssoc::usage="insert input and its modification into association, creating nested association/dataset 
type objects";
growForkBranch::usage="simultaneously copies the data under path into 's' and forks a mod(data) into new named field 
(grows a double-fork out of a branch)";
growBranch::usage="either inject data into assoc; or nest a given branch with a copy/mod(copy) of the data";
forkBranch::usage="adds nested branch at arbitrary point and with arbitrary data";
nestedAssociate::"add a field to nested association";
clearPlot::usage="updating theme for presentation figures via Show";
distMatrixHistogram::usage="plot histogram of distance matrix calculated from supplied data";
dimReducePacket::usage="return association with reducer functions, reduced vectors and reconstructed data";
histogram2D::usage="simple 2D histogram of a nD hyperspectral array. Last dimension is assumed to be the variable coordinate";
(*added to git*)
quickShape::usage="quickly reshape List from 2D to 3D or otherwise. Assumes that last dimension 
remains unchanged (e.g. hyperspectral data)";
dimCheck::usage="check dimensionality of array. Returns true of d>= dimensionality";
adjustPlot::usage="a nice restyler. Supply [plot, ListofLineProps, graphicsOptions]";
CloseAllInputCells::usage="good for demo. Close all inputs";
OpenAllInputsCells::usage="good for demo. Open all inputs";
testListAssociation::usage="quick peek at keys, dimensions or contents of the variable, depending on type and size";
colorGrads::usage="default color gradients with their namelabels for use with the ColorFunction";
niceMatrixPlot::usage="autoscales chosen colorbar onto the range of data, and shows the colorbar";
$::usage="echoes a function inserted into // pipeline";
$$::usage="pass through function. Doesn't enact anything in square brackets, but let's the value move forward down the monad.";
physicalTicks::usage="provides an array of {i,tick[i]} for use in labeling array ticks";
fitFunc1D::usage="helper function for 1D fitting. Strict requirement on formatting. See header for details";
assignSymbol::usage="assign value to symbol expressed by string";
reportGrid::usage="quick peek at a grid 3Ds file (attrs + a few plots); Overloaded to take advatnage of existing grid->Association conversions";
colobar::usage="generate density plot scaled and shaped as a colorbar on the right. Takes care of tricky color-scaling";
imageScalebar::usage ="feed 2D channel (zf, isoslice etc) and attrs -> get image, scalebar and colorbar";
normalize::usage="curried function for normalization and flattening";
denoise::usage="curried function for PCA denoising";
differentiate::usage="curried function for tunable differentiation (via \[Sigma]-parameter)";
plotStyle::usage="default rescale of labels and line thicknesses on the plot";
readDat::usage="import single dat file";
NiceGridDark::usage="version of NiceGrid optimized for dark background";
attachX::usage="returns association with 'xx' field, either occupied by e.g. 'sweep_signal' or Range@Last@Dimensions default";
kill::usage="terminate after n seconds -> first parameter";
head::usage="preview a structure by showing first n members (n can be negative -> tail)"
headRandom::usage="preview a structure by showing n Random  members (n can only be positive)"



(* ::Subsection:: *)
(*clustering*)


(*pca\[Bullet]kmeans::usage="curried function for PCA/Kmeans clustering";*)
caCluster::usage="curried function for generalized component analysis and clustering";
clusterCenters::usage="curried function for extracting 1D cluster centers. Requires x coordinate and oout of ca\[Bullet]cluster";


(* ::Subsection:: *)
(*python functions into WL*)


pyF::usage = "Quick wrapper for a python function. use pyF[py]@'pythonstring'";
pyBlobs::usage = "Scikit's blob dog, doh and log functions channeled to WL";
pySciKit::usage ="Portal to scikits clustering and dimension reduction functionalities";


(* ::Subsection:: *)
(*image analysis functions*)


numPartitions::usage = "Find how many image partitions one will get from a given image";
meshGrid::usage = "Replicates numpy's meshgrid function";
bgSubtract::usage = "Subtract polynomial background. Returns NumericArray. Good for 
						direct plug into ImageAdjust@Image@Normal@#";
pyHistogram::usage = "numpy function for histogram. Not sure it's really faster";
diskRoiMask::usage = "create a disk matrix around a specific pixel in the image. Returns mask, that when flattened can be applied directly to hypespectral
data-set via Pick";


(* ::Subsection:: *)
(*1D analysis*)


removeSpikes::usage = "remove spikes from spectra with quantile regression";


(* ::Subsection:: *)
(*viz functions*)


tickScale::usage="rescale ticks after Show, using Show[plotHandle,Ticks->{tickScale[plotHandle,factor],Automatic}] for example";
ticks::usage="explicit definition of ticks and subticks. Insert in instead of Automatic into ticklabels";


(* ::Subsection:: *)
(*SMIM functions*)


loadSMIM::usage="load smim signals from h5 data files";
parseSMIM::usage="parse a SMIM-containing h5 file from Asylum as recorded by Stu";


(* ::Subsection:: *)
(*clustering functions*)


splitTrainValidate::usage = "split a list of data (any kind) into train/validate portions";


(* ::Code::Initialization::GrayLevel[0]:: *)
Begin["`Private`"];


(* ::Subsection:: *)
(*mini-monadic functionality*)


SetAttributes[$,HoldAll];
x_ \[DoubleLongRightArrow]y_:=x//(EchoFunction[y][#]&);
x_ \[DoubleLongRightArrow]$[y_]:=x//y;
x_\[DoubleLongRightArrow]y_\[DoubleLongRightArrow]z__ :=(x//(EchoFunction[y][#]&))\[DoubleLongRightArrow]z;
x_\[DoubleLongRightArrow]$[y_]\[DoubleLongRightArrow]z__ :=(x//y)\[DoubleLongRightArrow]z;



kill[t_:10][expr_] := TimeConstrained[expr,t];
head[expr_, num_:5] := Take[expr,num];
headRandom[expr_, num_:5] := RandomSample[expr,num];


(*x_ \[DoubleLongRightArrow]y_:=x//y;
x_\[DoubleLongRightArrow]y_\[DoubleLongRightArrow]z__ :=(x//y)\[DoubleLongRightArrow]z;*)

(*functions below are activated if  defintions of \[DoubleLongRightArrow] above are used
SetAttributes[$,HoldAll];
$[func_]:=(EchoFunction[func][#])&; (*this one automatically returns #*)
$[func_,res_?AssociationQ]:=(EchoFunction[AssociateTo[res,ToString@(Length@res+1)-> func@#]][#]&);
$[func_,res_?AssociationQ, key_?StringQ]:=(AssociateTo[res, key-> Echo@func@#];#)&;
$$[___]=(#)&; (*Pass through function for the mini-Monadic*)
*)


(* ::Subsection:: *)
(*importing functionality*)


readDat[fname_]:=Block[{lst, datapos, assc,header, data, chanpos, chanposOffset, channelsNames},
(lst = Import[fname];
datapos = First@Flatten@Position[lst,"[DATA]"];
header =lst[[1;;datapos]];
data = lst[[ datapos+1;;]];
chanpos = First@#&/@Position[StringPosition[data[[1]],"("~~__~~")"],{1,3}];
chanposOffset = Join[{1},(chanpos + 1)[[1;;-2]]];
channelsNames = MapThread[StringJoin@data[[1]][[#1;;#2]]&,{chanposOffset,chanpos}];
assc = <|MapThread[#1-> #2&,{channelsNames,Transpose@data[[2;;]]}]|>;
assc["Z"]= Last@Flatten@(Pick[#,ContainsAll[#,{"offset","Z"}]]&/@lst);
assc)
];


(* ::Subsection:: *)
(*reporting functionality*)


reportCore[grd_?AssociationQ]:=
	Block[{attrs=grd["header"]},
	(attrs["bias"] = {Min@#, Max@#}&@grd["sweep_signal"];
	attrs["chanPlot"]= Grid[{{ListPlot[Transpose[{Normal@grd["sweep_signal"],#}]&/@#]&@RandomSample[Flatten[Normal@grd["Current (A)"],1],10],
	ImageAdjust@Image@bgSubtract@grd["topo"]}}];
	NiceGridDark@KeyDrop[attrs,
		{"num_parameters", "measure_delay","experiment_size","experimental_parameters","fixed_parameters"}])];

reportChans[grd_?AssociationQ]:=
	Block[{reportGrid},(
		reportGrid =KeyTake[grd,Complement[Keys@grd,{"params","Z (m)","sweep_signal", "header"}]];
		NiceGridDark@Partition[#,3]&@(If[#=="topo",
		Labeled[ImageAdjust@Image@bgSubtract@reportGrid[#],"topo",Top],
		MatrixPlot[Part[reportGrid[#],All,All,2],PlotLabel->#]]&/@Keys@reportGrid
	))];
(*Pick[Keys@reportGrid,Values@(Length@Dimensions@#&/@reportGrid),_?(#\[Equal]3&)]*)

reportGrid[gridFileName_?StringQ]:= 
	Block[{grd},
		(grd = parse3DS[gridFileName];
		Echo@reportCore[grd];
		grd)];

reportGrid[grd_?AssociationQ]:= reportCore[grd];

reportGrid[grd_?AssociationQ, chans_?IntegerQ]:=Block[{},
	(Echo@reportCore[grd];
	reportChans[grd])];


(* ::Subsection:: *)
(*data processing*)


normalize[chanNorm_:(#/1*^-12&)][data_] := NumericArray@Flatten[Normal@chanNorm@data,1];


denoise[dimReduceComponents_:3][data_]:=
	Block[{dimReducer},
		dimReducer=dimReducePacket[Normal@data,dimReduceComponents];
		NumericArray@dimReducer["ReducerFunction"][data,"ReconstructedData"]];


differentiate[\[Sigma]_:0][data_]:= NumericArray@(-1 DerivativeFilter[#,{1},\[Sigma]]&/@Normal@data )


(*pca\[Bullet]kmeans[ncomps_:2, nclust_:2][data_?AssociationQ]:=
	Block[{ct=<||>},(
		ct ["params"]= <|"chan"-> First@Keys@data,"components"->  ncomps, "clusters"-> nclust, "colors"-> (ColorData[24, "ColorList"][[#]]&/@{1,5,2,7,10})|>;
		ct["PCA"] =  DimensionReduce[First@data,ncomps,Method->"PrincipalComponentsAnalysis"];
		ct["PCA\[Bullet]kMeans"] = ClusterClassify[ct["PCA"], nclust, Method->"KMeans", DistanceFunction->EuclideanDistance];
		ct["PCA\[Bullet]kMeans\[Bullet]scatter"] = ListPlot[
		Style[Pick[ct["PCA"], ct["PCA\[Bullet]kMeans"]@ct["PCA"], #],ct["params"]["colors"][[#]]]&/@Range[nclust],AxesLabel-> {"PCA1","PCA2"}];
		ct["PCA\[Bullet]kmeans\[Bullet]centers"] =
		ListLinePlot[
			Style[
			Transpose[{1*^3 Normal@data["xx"],
			Mean[Pick[First@data,ct["PCA\[Bullet]kMeans"]@ct["PCA"], #]]}],ct["params"]["colors"][[#]]
			]&/@Range[nclust]];
		ct["PCA\[Bullet]kMeans\[Bullet]scores\[Bullet]map"]=
		Show[ct["PCA\[Bullet]kMeans\[Bullet]scatter"],Graphics[{Opacity-> 0.2,First@#}],ct["PCA\[Bullet]kMeans\[Bullet]scatter"]]&@(
		ArrayPlot[#, ColorFunction->(ct["params"]["colors"][[Floor[#+1]]]&), DataReversed->{True,False},DataRange->{{Min@ct["PCA"],Max@ct["PCA"]},{Min@ct["PCA"],Max@ct["PCA"]}}, Frame->None]&@ParallelTable[ct["PCA\[Bullet]kMeans"]@{j,i},{i,Range[Min@ct["PCA"],Max@ct["PCA"],1]},{j,Range[Min@ct["PCA"],Max@ct["PCA"],1]}]);
		ct)];*)


caCluster[dimRedFunc_:(DimensionReduce[#]&), clusterFunc_:(ClusterClassify[#]&)][data_] :=
		Block[{ct=<||>,reducedDims, nClusters},(
		ct["params"]= <|"clusterFunc"-> clusterFunc,
		"dimRedFunc"-> dimRedFunc, "colors"-> (ColorData[24, "ColorList"][[#]]&/@{1,5,2,7,10})|>;
		ct["dimRed"] =  NumericArray@dimRedFunc@data;
		ct["trainedfunc"] = clusterFunc@Normal@ct["dimRed"];
		ct["labels"] = NumericArray@ct["trainedfunc"]@ct["dimRed"];
		reducedDims = Last@Dimensions@ct["dimRed"];
		nClusters = Echo@Max@ct["labels"];
		ct["scatter"] = If[reducedDims < 3,ListPlot[
			Style[Pick[Normal@ct["dimRed"], Normal@ct["labels"], #],ct["params"]["colors"][[#]]]&/@Range@nClusters,
			AxesLabel-> Table["C" <> ToString[j],{j,Range@nClusters}],PlotRange->All],Echo@"need to extend plotting to 3D"];
		ct["map"]=
			Show[ct["scatter"],DensityPlot[ct["trainedfunc"]@{x,y},
			{x,Min@ct["dimRed"],Max@ct["dimRed"]},{y,Min@ct["dimRed"],Max@ct["dimRed"]},
			Frame->None,ColorFunction->(Opacity[0.3,ct["params"]["colors"][[#]]]&),ColorFunctionScaling->False]];
		ct)];



clusterCenters[ct_?AssociationQ, styleOpts_:Thickness[0.005]][data_, xx_,mod_:(#&)] :=Block[{},(
			ListLinePlot[
			Style[
			Transpose[{Normal@xx,
			mod[Mean[Pick[data,Normal@ct["labels"], #]]]}],ct["params"]["colors"][[#]], styleOpts
			]&/@Range@Max@ct["labels"]]
			) ];


removeSpikes[data_,quantiles_:{0.05,0.95}, interp_:25]:=
Block[{qfuncs, topOutliers, outlierRegions, newData, outlierWindows},
(
qfuncs=ResourceFunction["QuantileRegression"][data,interp,quantiles];
topOutliers=Flatten@(Position[data,#]&/@Select[data,qfuncs[[-1]][#[[1]]]<0.7 #[[2]]&]);
newData =Part[data,Complement[Range@Length@data,Flatten[#]&@(Join[Range[Max[{1,#-4}],Min[{#+4,Length@data}]]]&/@topOutliers)]];
intrp =ListInterpolation[Sequence@@{Last@#,{First@#}}]&@Transpose@newData;
Transpose[{#,intrp@#}]&@First@Transpose@data
)];


(* ::Subsection:: *)
(*auxiliary functions*)


attachX[xx_:None][data_]:=<|"data"->data, "xx"-> If[MatchQ[xx,None],Range@Last@Dimensions@data,xx]|>;


(*JsonImport[filename_]:=Uncompress@Import[filename]
JsonExport[data_,filename_:""]:=Export[If[filename=="", SymbolName[Unevaluated@data],filename]<>".json",Compress[data]]
saveDump[]:= Row[#]&@{Button["Save Kernel",Module[{},{DumpSave[StringTake[#,{1,-3}]&@NotebookFileName[]<>"mx","Global`"],Print["Saved "<>DateString[]]}]],
Button["Load Kernel",
Module[{},{Get[StringTake[#,{1,-3}]&@NotebookFileName[]<>"mx"],Print["Loaded "<>DateString[]]}]],
Button["Get Calme",Get["Calme`"]]}
initNB[]:=Module[{},{
		SetOptions[$FrontEndSession,
		AutoStyleOptions->{"SymbolContextStyles"->
		{"Global`"->{FontColor->RGBColor[{1,165/256,0}], FontVariations->{Shadow->False}}}}]
		}]
figureToClipboard[graph_]:= Module[{},Export["pp2.png",graph,ImageResolution->200,Background->None];
CopyToClipboard[Import["pp2.png"]];];
chainAssoc[src_:?AssociationQ, mod_:None,keys_:{"s","d"}(*source/drain*)]:=<|First@keys->src,Last@keys->mod|>;
growBranch[assc_?AssociationQ, path_?ListQ, newkey_:"s", mod_:(#&)]:=ResourceFunction["NestedAssociate"][assc,path-><|newkey-> mod@Extract[assc,path]|>];
forkBranch[assc_?AssociationQ,path_?ListQ, data_]:= ResourceFunction["NestedAssociate"][assc,path->data];
(*growForkBranch[assc_?AssociationQ, path_?ListQ, newkey_?StringQ, mod_:(#&)]:=
	Block[{assc2=ResourceFunction["NestedKeyDrop"][assc, path]},
		ResourceFunction["NestedAssociate"][assc2,path \[Rule] <|"s" \[Rule] Extract[assc2,path], newkey \[Rule] mod@Extract[assc2,path]|>]];
*)
growForkBranch[assc_?AssociationQ, path_?ListQ, newkey_?StringQ, mod_:(#&)]:=
	ResourceFunction["NestedAssociate"][assc,path -> <|"s" -> Extract[assc,path], newkey -> mod@Extract[assc,path]|>];

colorGrads = GraphicsGrid[Partition[Tooltip[ColorData[#,"Image"],#]&/@ColorData["Gradients"],3],ImageSize->300];

testListAssociation[x_] := Which[ListQ@#,If[Max@Dimensions@#<100,#,Dimensions@#],AssociationQ@#,(Print["Keys:"];Keys@#)]&@x;
assignSymbol[s_?StringQ,val_]:=(ClearAll[s];Activate[Inactive[Set][Symbol[s],val]]);*)



growBranch[val_?(Not[AssociationQ@#]&), newkey_:"s", mod_:(#&)]:=<|newkey-> mod@val|>;
clearPlot[p_]:=Show[p,BaseStyle-> {FontFamily->"Latin Modern Roman",FontSize->14},AxesStyle-> Thickness[0.003]];
quickShape[arr_?ListQ,dims_?ListQ]:=ArrayReshape[arr,Join[dims,{Last@Dimensions@arr}]];
dimCheck[arr_?ListQ, d_]:=(Length@Dimensions@arr>=2);
adjustPlot[plot_Graphics,styles_List,op:OptionsPattern[Graphics]]:=Module[{x=styles},Show[MapAt[#/.{__,ln__Line}:>{Directive@Last[x=RotateLeft@x],ln}&,plot,1],op]];



CloseAllInputsCells[]:=Module[{nb,cells},nb=EvaluationNotebook[];
		cells=Cells[nb,CellStyle->"Input"];
		SetOptions[#,CellOpen->False]&/@cells;];
OpenAllInputsCells[]:=Module[{nb,cells},nb=EvaluationNotebook[];
		cells=Cells[nb,CellStyle->"Input"];
		SetOptions[#,CellOpen->True]&/@cells;];


(* ::Subsection:: *)
(*run on startup*)


initNB[];
Needs["HierarchicalClustering`"];


plotStyle[] := Block[{},{BaseStyle->Directive[FontFamily->"Sansa",FontSize->18], Axes->False, Frame->True, FrameStyle->Directive[ Thickness[0.002]],ImageSize->500,PlotRange->All}];


(* ::Section::GrayLevel[0]:: *)
(*Define Fourier and sliding functions*)


(* ::Code::Initialization::GrayLevel[0]:: *)
fftshift[dat_?ArrayQ,k:(_Integer?Positive|All):All]:=Module[{dims=Dimensions[dat]},RotateRight[dat,If[k===All,Quotient[dims,2],Quotient[dims[[k]],2] UnitVector@@{Length[dims],k}]]];


(* ::Code::Initialization::GrayLevel[0]:: *)
ifftshift[dat_?ArrayQ,k:(_Integer?Positive|All):All]:=Module[{dims=Dimensions[dat]},RotateRight[dat,If[k===All,Ceiling[dims/2],Ceiling[dims[[k]]/2] UnitVector@@{Length[dims],k}]]];


(* ::Code::Initialization::GrayLevel[0]:: *)
imageCenter[im_?ImageQ] := Floor@Dimensions@ImageData@im/2.;


(* ::Code::Initialization::GrayLevel[0]:: *)
hannWindow[im_?ArrayQ] := Block[{w,h,hg,wg}, {w,h} = Dimensions@im; {hg, wg} = meshGrid[Range[h],Range[w]]; 
									Times[HannWindow[hg/h-0.5],HannWindow[wg/w-0.5]]];


(* ::Code::Initialization::GrayLevel[0]:: *)
plotRanger[im_,nsigma_:2]:={#1-#2,#1+#2}&@@{Mean@#,nsigma* StandardDeviation@#}&@Flatten@im;


(* ::Code::Initialization::GrayLevel[0]:: *)
bandPass[im_?ArrayQ,d1_?IntegerQ,d2_?IntegerQ]:=Module[{imInternal, mask, imfft, imfiltered, imfftMasked, imMod},
imInternal = Part[im,Range@#,Range@#]&@Min@Dimensions@im;
(*assure square array*)
mask = DiskMatrix[Max[#1]+1,Length@#2]-DiskMatrix[Min[#1],Length@#2]&@@{{d1,d2},imInternal};
imfft=fftshift@Fourier@imInternal;
imfftMasked = imfft*mask;
imfiltered =InverseFourier@ifftshift@(imfftMasked);
imMod = (#//Abs[1+#]&//Log//Image//ImageAdjust//DynamicImage)&;
Grid[{{imMod@imfftMasked, imMod@imfiltered}}]]





(* ::Code::Initialization::GrayLevel[0]:: *)
bedOfNails[xp_,yp_,sz_]:=SparseArray@Flatten@Table[{xp*i,yp*k}->1,{i,1,sz/xp},{k,1,sz/yp}];


(* ::Code::Initialization::GrayLevel[0]:: *)
showFFT[im_?ArrayQ] := ImageAdjust@Image@Raster[#,ColorFunction->"Cool"]&@Log[#+1]&@Abs@fftshift@Fourier@im;


(* ::Code::Initialization::GrayLevel[0]:: *)
baseFFT[im_?ArrayQ] :=  Block[{hw,imC},
					imC = (NumericArray@#)*(NumericArray@HannWindow@#)&@im;
					Abs@fftshift@Fourier@Normal@imC];


(* ::Code::Initialization::GrayLevel[0]:: *)
numPartitions[im_?ArrayQ, pWidth_?ListQ, pStride_?ListQ] := Floor[(Dimensions[im][[#]]-pWidth[[#]])/pStride[[#]] +1]&/@Range@Length@Dimensions@im ;


(* ::Code::Initialization::GrayLevel[0]:: *)
(*meshGrid[x_List,y_List]:={ConstantArray[x,Length[x]],Transpose@ConstantArray[y,Length[y]]}*)
meshGrid[xx_,yy_]:=Block[{py,mgrid},
(py=StartExternalSession["Python"];
mgrid = Normal@pyF[py]@("import numpy as np; np.meshgrid(range("<>ToString@(xx)<>"),range("<>ToString@(yy)<>"))")+1;
DeleteObject[py];
Return[mgrid, Block];)]



(* ::Code::Initialization::GrayLevel[0]:: *)
(*bgSubtract[py_,zArr_?ArrayQ]:=Module[{zArrIJ, bgFit,bg,xx,yy,a1,b1,c1,x,y},
zArrIJ = Table[{ii,jj,#[[ii,jj]]},{ii,1,First@Dimensions@#,10},{jj,1,Last@Dimensions@#,10}]&@zArr;
bgFit = NonlinearModelFit[Flatten[zArrIJ,1],a1 x + b1 y + c1,{a1, b1, c1},{x,y}];
{xx,yy}=meshGrid[py,#[[1]],#[[2]]]&@Dimensions@zArr;
Echo@NumericArray@((a1*xx+b1*yy + c1)/.bgFit["BestFitParameters"]);
bg = Echo@((a1*Normal@xx+b1*Normal@yy+c1)/.bgFit["BestFitParameters"]);
NumericArray[zArr,"Real32"]-bg
];*)
bgSubtract[zArr_]:=
Block[{zArrIJ, bgFit,bg,xx,yy,a2,b2,a1,b1,c1,x,y},
(
	zArrIJ = ParallelTable[{ii,jj,#[[ii,jj]]},{ii,1,First@Dimensions@#,Floor[First@Dimensions@#/5.]},{jj,1,Last@Dimensions@#,Floor[Last@Dimensions@#/5.]}]&@zArr;

	bgFit = NonlinearModelFit[Flatten[zArrIJ,1],a2 x^2 + a1 x + b2 y^2+ b1 y + c1,{a2,b2,a1, b1, c1},{x,y}];
	ParallelTable[#[[ii,jj]]-bgFit[ii,jj],{ii,1,First@Dimensions@#,1},{jj,1,Last@Dimensions@#,1}]&@zArr
)];


(* ::Chapter::GrayLevel[0]:: *)
(*Python inherited functions*)


pyF[py_] := ExternalEvaluate[py, #]&;


(* ::Code::Initialization::GrayLevel[0]:: *)
(*pyBlobs[py_]:=Module[{},
ExternalEvaluate[py,"from skimage.feature import blob_log, blob_dog, blob_doh"];
<|"blobLog"-> ExternalFunction[py, "lambda im, min_s=1, max_s=30, n_s=10, ts=0.1, o_l=0.5, l_s=False, e_b=True:
			blob_log(im, min_sigma=min_s,max_sigma=max_s,num_sigma=n_s,threshold=ts,overlap=o_l,log_scale=l_s,exclude_border=e_b)"],
"blobDog"-> ExternalFunction[py, "lambda im, min_s=2, max_s=10, s_r = 1.6, t_s=0.1, o_l=0.5,e_b=False: 
			blob_dog(im, min_sigma=min_s,max_sigma=max_s,sigma_ratio=s_r,threshold=t_s,overlap=o_l,exclude_border=e_b)"],
"blobDoh"-> ExternalFunction[py, "lambda im, min_s=2, max_s=10, n_s = 10, t_s=0.01, o_l=0.5,l_s=False: 
			blob_doh(im, min_sigma=min_s,max_sigma=max_s,num_sigma=n_s,threshold=t_s,overlap=o_l,log_scale=l_s)"]
|>
]*)


pyBlobs[py_]:=ExternalEvaluate[py,"from skimage.feature import blob_log, blob_dog, blob_doh"];
(*<|"blobLog"-> ExternalFunction[py, "lambda im, min_s=1, max_s=30, n_s=10, ts=0.1, o_l=0.5, l_s=False, e_b=True:
			blob_log(im, min_sigma=min_s,max_sigma=max_s,num_sigma=n_s,threshold=ts,overlap=o_l,log_scale=l_s,exclude_border=e_b)"],
"blobDog"-> ExternalFunction[py, "lambda im, min_s=2, max_s=10, s_r = 1.6, t_s=0.1, o_l=0.5,e_b=False: 
			blob_dog(im, min_sigma=min_s,max_sigma=max_s,sigma_ratio=s_r,threshold=t_s,overlap=o_l,exclude_border=e_b)"],
"blobDoh"-> ExternalFunction[py, "lambda im, min_s=2, max_s=10, n_s = 10, t_s=0.01, o_l=0.5,l_s=False: 
			blob_doh(im, min_sigma=min_s,max_sigma=max_s,num_sigma=n_s,threshold=t_s,overlap=o_l,log_scale=l_s)"]
|>
*)


pySciKit[py_]:=
<|
"Blobs" -> Module[{},
	ExternalEvaluate[py,"from skimage.feature import blob_log, blob_dog, blob_doh"];
	<|"blobLog"-> ExternalFunction[py, "lambda im, min_s=1, max_s=30, n_s=10, ts=0.1, o_l=0.5, l_s=False, e_b=True:
			blob_log(im, min_sigma=min_s,max_sigma=max_s,num_sigma=n_s,threshold=ts,overlap=o_l,log_scale=l_s,exclude_border=e_b)"],
	"blobDog"-> ExternalFunction[py, "lambda im, min_s=2, max_s=10, s_r = 1.6, t_s=0.1, o_l=0.5,e_b=False: 
			blob_dog(im, min_sigma=min_s,max_sigma=max_s,sigma_ratio=s_r,threshold=t_s,overlap=o_l,exclude_border=e_b)"],
	"blobDoh"-> ExternalFunction[py, "lambda im, min_s=2, max_s=10, n_s = 10, t_s=0.01, o_l=0.5,l_s=False: 
			blob_doh(im, min_sigma=min_s,max_sigma=max_s,num_sigma=n_s,threshold=t_s,overlap=o_l,log_scale=l_s)"]|>],
		
"Manifold" -> Module[{},
	ExternalEvaluate[py,"from sklearn import manifold"];
	<|"tSNE"-> ExternalFunction[py, "lambda X, n_components=2, perplexity=5, n_iter=1000, init='random', random_state=0: manifold.TSNE(n_components=n_components, init=init,
                         random_state=random_state, perplexity=perplexity, n_iter=n_iter).fit_transform(X)"]|>
                         ],
                         
"Datasets" -> Module[{},
	ExternalEvaluate[py,"from sklearn import datasets"];
		<|"blobs"-> ExternalFunction[py, "lambda n_samples=2, n_features=2, centers=None, cluster_std=1.0: datasets.make_blobs(n_samples=n_samples, n_features=n_features, centers=centers, cluster_std=cluster_std, shuffle=True)"]|>
         ]         
|>



pyHistogram[py_]:=Module[{},
ExternalEvaluate[py,"from numpy import histogram"];
ExternalFunction[py,"lambda a, bins=10,range=None,normed=None,weights=None,density=None: histogram(a,bins=10,range=None,normed=None,weights=None,density=None)"]]


(* ::Subsection:: *)
(*dataXray connectivity*)


parse3DS[file3ds_] := Module[{xasc,gr2,coords,dataVars,attrs,py},(
  
    py=StartExternalSession["Python"];
	pyF[py]@"import data_xray.nanonisio as nio; import numpy as np";
	pyF[py]@(StringJoin["gr2 = nio.Grid('",file3ds,"')"]);
	xasc = pyF[py]@("gr2.signals");
	xasc["header"] = pyF[py]@("gr2.header");
	DeleteObject[py];
	xasc
	)]
	(*coords =(pyF[py]@"dict(gr2.ds.coords)");
	Echo@Normal@coords;
	dataVars = pyF[py]@"gr2.ds.data_vars";
	attrs=pyF[py]@"gr2.ds.attrs";
	gr2= pyF[py]@("gr2.ds['"<>coords[[1]]<>"'].values");
	xasc =<|#->pyF[py] @("gr2.ds['"<>#<>"'].values")|>&@coords[[1]];
	AssociateTo[xasc,#-> pyF[py]@("np.asarray(gr2.ds['"<>#<>"'].values,dtype=np.float)")]&/@dataVars;
	(*Print@TableForm@KeyValueMap[{#1,#2}&,#]&@attrs;*)
	xasc["attrs"]=attrs;
*)	


parseSXM[filesxm_] := Module[{xasc,gr2,coords,dataVars,attrs,py},
  py=StartExternalSession["Python"];
	pyF[py]@"import data_xray.nanonisio as nio; import numpy as np";
	pyF[py]@StringJoin["gr2 = nio.Scan('",filesxm,"')"];
	xasc = pyF[py]@("gr2.signals");
	xasc["header"] = pyF[py]@("gr2.header");
	DeleteObject[py];
	xasc
	(*coords =pyF[py]@"gr2.ds.coords";
	dataVars = pyF[py]@"gr2.ds.data_vars";
	attrs=pyF[py]@"gr2.ds.attrs";
	gr2= pyF[py]@("gr2.ds['"<>coords[[1]]<>"'].values");
	xasc =<|#->pyF[py] @("gr2.ds['"<>#<>"'].values")|>&@coords[[1]];
	AssociateTo[xasc,#-> pyF[py]@("np.asarray(gr2.ds['"<>#<>"'].values,dtype=np.float)")]&/@dataVars;
	(*Print@TableForm@KeyValueMap[{#1,#2}&,#]&@attrs;*)
	xasc["attrs"]=attrs;*)
	]


(* ::Subsection:: *)
(*data visualization*)


physicalTicks[src_,nticks_]:={#+1,(Round[src[[#+1]],0.001])}&/@Floor@Subdivide[Length@src-1,nticks-1];


tickScale[plotname_,factor_]:=Map[Times[#,{1,If[NumberQ[#[[2]]],1/factor,1],{1,1},{1,1}}]&,AbsoluteOptions[plotname,Ticks][[1,2,1]]]


ticks[min_,max_,step_:0.1,ticklabel_:(#&)]:=Table[If[ FractionalPart[i]==0.,{i,ticklabel@i,.02,Black},{i,"",.01,Black}],{i,Floor[min],Ceiling[max],step}]


singleSpectraViz[data_,chans_:{"cf"}]:=DynamicModule[{r={1,1}},Row@{Slider2D[Dynamic[r],{{1,1},#[[1;;2]]&@Dimensions@data[chans[[1]]],{1,1}},Appearance->{"Open"}],
Dynamic@Row[ListLinePlot[Transpose@@{Normal@{data["bias"],data[#][[r[[1]],r[[2]]]]}},ImageSize->Medium]&/@chans]}]


singleSpectraMapper[data_,chans_:{"cf"}]:=Dynamic[Module[{im,xp,yp,mp},{
im = ImageAdjust@Image[#,ImageSize->Medium]&@data["zf"][[;;,;;,128]];
mp =Floor/@(If[TrueQ[#==None],{1,1},#]&@MousePosition[{"Graphics",Image},{1,1}]);
Grid[{{Show[im,Graphics[{Red,PointSize[0.025],Point[Floor/@mp]}]], SpanFromLeft},
Row[ListLinePlot[Transpose@@{Normal@{data["bias"],data[#][[mp[[1]],mp[[2]]]]}},ImageSize->Medium]&/@chans]
}]
}]]


(*This needs to be rewritten, so that data, chans and topo come in as already
data, not for reformatting inside the function*)

spectraPicker[data_?ListQ, topoData_?(dimCheck[#,2]&), xvec_:{}]:=
DynamicModule[{list=<|1->{}|>,lst,curGroup = 1, delpos,coordList, pickedPos, plotSpec,xv},
	Row@{
		EventHandler[
			Module[{ datum},
	coordList = Transpose[Flatten/@meshGrid[#1,#2]&@@Range/@Dimensions@#]&@topoData;
			xv =If[Length[xvec]==0,Range@Last@Dimensions@First@data,xvec];
				plotSpec[datum?ListQ,pickedPos_?ListQ,xx_]:=Transpose[{xx,datum[[Sequence@@#]]}]&/@pickedPos;
					Grid[{{
					Dynamic[Framed@Show[
								ImageAdjust@Image[#,ImageSize->Large]&@topoData,
								Graphics[{Red,Point[list@curGroup],
								EdgeForm[Directive[Thick,Dashed,Blue]],
								Transparent,Disk[#,2]&/@list[curGroup]},
								PlotRange->200]]],
					Dynamic[(
						Print[pickedPos];
						pickedPos =coordList[[#]]&/@Flatten[Nearest[coordList-> "Index",#]&/@list[curGroup]];
						Function[{d,pos},ListPlot[Transpose[{xv,Part[d,Sequence@@#]}]&/@pos]][#,pickedPos]&/@ data)]
						}}]],
(*this is picker for points within the image*)	
			
		{{"MouseClicked",1}:>{AppendTo[list[curGroup],MousePosition@"Graphics"],lst = list},
		{"MouseClicked",2}:>Module[{},{delpos =Nearest[list[curGroup]->"Index",MousePosition@"Graphics"], list[curGroup]=If[Length@list[curGroup]>0,Drop[list[curGroup],delpos],list[curGroup]],lst = list}]
		}
	]}]


meanSpectraPlot[data_?AssociationQ, chan_:{"cf"},subsample_:All,OptionsPattern[ListPlot]]:=
	Which[And@@(MemberQ[Keys@data,#]&/@chan),#]&@
		Module[{chanData,meanChanError},
			Row@{chanData = (#/Abs@Mean@Flatten@#)&@Part[Flatten[Normal@data[#],1],subsample]&/@chan;
				meanChanError = Around@@#&/@Transpose[{Mean@#,Sqrt@Variance@#}]&/@chanData;
				Row@(ListPlot[Transpose@{Normal@data["bias"],#[[2]]},ImageSize->Medium,
				AxesLabel->{"bias",Part@@{chan,#[[1]]}},
				PlotStyle->OptionValue[PlotStyle]]&/@MapIndexed[Append[#2,#1]&,#]&@meanChanError)}]
(*Alternative definition for averaging over the list*)

meanSpectraPlot[data_?ListQ, xaxis_:{}, op: OptionsPattern[Graphics]]:=
	Block[{meanChanError, xx},(
		xx=If[Length[xaxis]==0,Range@Last@Dimensions@data,xaxis];
		meanChanError = Around@@#&/@Transpose[{Mean@#,Sqrt@Variance@#}]&@data;
		ListLinePlot[Transpose@{xx,meanChanError},op]
	)]


chanHistogram[data_?AssociationQ, chan_:{"cf"}, bins_:30, mod_:(#&), op:OptionsPattern[DensityHistogram]]:=Which[And@@(MemberQ[Keys@data,#]&/@chan),#]&@
Module[{histDim, plotMod, histPlots},Row@{
	histDim = Transpose[{Normal@data["bias"],#}]&/@mod@Flatten[Normal@#,-2+Length@Dimensions@#]&@data[#]&/@chan;
	histPlots = DensityHistogram[Flatten[#,1],bins]&/@histDim;
	Row[Show[#,op]&/@histPlots]}]



histogram2D[bins_:30,op: OptionsPattern[DensityHistogram]][xvec_:{}][data_?ListQ] :=
Module[{histDim, plotMod, histPlots,xx},(
		xx = If[Length[xvec]==0,Range@Last@Dimensions@data,xvec];
		histDim = Flatten[Normal@#,-2+Length@Dimensions@#]&@data;
		histDim = Transpose[{xx,#}]&/@histDim;
		histPlots = DensityHistogram[Flatten[histDim,1],bins, op]
		)]



(* ::Subsection:: *)
(*image visualization*)


colorbar[{min_,max_},colorFunction_: Automatic,divs_: 150]:=
	(*FrameLabel\[Rule]{{None,Row[{Subscript["t","esc"]}]},{None,None}},LabelStyle\[Rule]Directive[FontFamily\[Rule]"Helvetica",20] <- Use this to label the scalebar*)
	DensityPlot[y,{x,0,0.1},{y,min,max},AspectRatio->20,PlotRangePadding->0,PlotPoints->{2,divs},MaxRecursion->0,Frame->True,FrameTicks->{{None,All},{None,None}},FrameTicksStyle->Directive[FontFamily->"Helvetica",20,Plain],ColorFunction->colorFunction];


imageScalebar[attrs_?AssociationQ, cf_:"GrayYellowTones", scaleColor:White, sprinkles_:Nothing, opts:OptionsPattern[MatrixPlot]][imData_?ListQ]:=
	Block[{scaleBarValue, scaleBarPixels, scaleBar, imPlot, imPlotScale, min, max},
	(
		{min,max}={Min@#,Max@#}&@Flatten@Flatten@imData;
		scaleBarValue = 0.2 attrs["scan_range"][[1]]  1*^9;(*20% of the scanned range*)
		scaleBarPixels = Floor@(1*^-9 scaleBarValue*attrs["scan_pixels"][[1]]/attrs["scan_range"][[1]]);
		scaleBar = {Text[Style[ToString@NumberForm[scaleBarValue,2] <> " nm",scaleColor,25],{70,75}],{scaleColor,AbsoluteThickness[5],Line[{{20,50},{20+scaleBarPixels,50}}]}};
		imPlot = MatrixPlot[imData, Frame -> None,PlotRange -> All, ColorFunctionScaling->False,
			ColorFunction -> (ColorData[cf][Rescale[#,{1.1*min,0.9*max}]]&)];
		imPlot = Show[{imPlot, sprinkles}];
		imPlotScale = Graphics[scaleBar,PlotRange->Transpose@{{0,0},Dimensions@imData},Prolog->{Inset[imPlot,Center,Center,Dimensions@imData]}];
		Row[{
			Show[imPlotScale, opts],
			Show[colorbar[{Min@Flatten@imData,Max@Flatten@imData},cf,150],opts]
			}]

	)];



imageScalebar[cf_:"GrayYellowTones", sprinkles_:Nothing, opts:OptionsPattern[MatrixPlot]][imData_?ListQ]:=
	Block[{scaleBarValue, scaleBarPixels, scaleBar, imPlot, imPlotScale, min, max},
	(
		{min,max}={Min@#,Max@#}&@Flatten@Flatten@imData;
		scaleBarValue = 0.2 attrs["scan_range"][[1]]  1*^9;(*20% of the scanned range*)
		scaleBarPixels = Floor@(1*^-9 scaleBarValue*attrs["scan_pixels"][[1]]/attrs["scan_range"][[1]]);
		scaleBar = {Text[Style[ToString@NumberForm[scaleBarValue,2] <> " nm",scaleColor,25],{70,75}],{scaleColor,AbsoluteThickness[5],Line[{{20,50},{20+scaleBarPixels,50}}]}};
		imPlot = MatrixPlot[imData, Frame -> None,PlotRange -> All, ColorFunctionScaling->False,
			ColorFunction -> (ColorData[cf][Rescale[#,{1.1*min,0.9*max}]]&)];
		imPlot = Show[{imPlot, sprinkles}];
		imPlotScale = Graphics[scaleBar,PlotRange->Transpose@{{0,0},Dimensions@imData},Prolog->{Inset[imPlot,Center,Center,Dimensions@imData]}];
		Row[{
			Show[imPlot, opts],
			Show[colorbar[{Min@Flatten@imData,Max@Flatten@imData},cf,150],opts]
		}]
	)];



niceMatrixPlot[clrs_:"TemperatureMap",op:OptionsPattern[MatrixPlot]][data_]:=
	Block[{min, max},(
		{min,max}={Min@#,Max@#}&@Flatten@Flatten@data;
		MatrixPlot[data, ColorFunctionScaling->False,
			ColorFunction -> (ColorData[clrs][Rescale[#,{min,max}]]&), op])];


diskRoiMask[srcImage_,diskXY_?ListQ, diskRadius_?NumberQ]:=Block[{xs,ys,dims,radius,mask},(
dims=Dimensions@srcImage;
	ys=Array[N[#1]&,dims]-diskXY[[1]];
	xs=Array[N[#2]&,dims]-diskXY[[2]];
radius=Sqrt[xs^2+ys^2];
mask=UnitStep[diskRadius-radius])];


removeSpikes[data_,quantiles_:{0.05,0.95}, interp_:25]:=
Block[{qfuncs, topOutliers, outlierRegions, newData, outlierWindows},
(
qfuncs=ResourceFunction["QuantileRegression"][data,interp,quantiles];
topOutliers=Flatten@(Position[data,#]&/@Select[data,qfuncs[[-1]][#[[1]]]<0.7 #[[2]]&]);
newData =Part[data,Complement[Range@Length@data,Flatten[#]&@(Join[Range[Max[{1,#-4}],Min[{#+4,Length@data}]]]&/@topOutliers)]];
intrp =ListInterpolation[Sequence@@{Last@#,{First@#}}]&@Transpose@newData;
Transpose[{#,intrp@#}]&@First@Transpose@data
)];


(* ::Subsection:: *)
(*Fitting*)


fitFunc1D[blocks_?ListQ,data_?ListQ]:=
(* Example of blocks: 
xvariable should be xx. "func" is the derisred fitting functions, "constr" \[Rule] constraints; "guess" \[Rule] initial parameter guesses
{<|"func"\[Rule] {mc1 PDF[NormalDistribution[ma1,mb1],xx]}, "constr"\[Rule] {mc1>0, ma1<0.}, "guess"\[Rule] {{mc1,2.},{ma1,-1.},{mb1,1.}}|>,
<|"func"\[Rule] {mc2 PDF[NormalDistribution[ma2,mb2],xx]}, "constr"\[Rule] {mc2>0, ma2>0.}, "guess"\[Rule] {{mc2,2.},{ma2,1.},{mb2,1.}}|>}
data \[Rule] same as standard, list of {{Subscript[x, i],Subscript[y, i]}}
*)
Block[{fitAssc},
	(fitAssc = Merge[blocks,Flatten[#,1]&];
	NonlinearModelFit[data,Join[List@Total@fitAssc["func"],fitAssc["constr"]],fitAssc["guess"],x2])];


(* ::Subsubsection:: *)
(*Clustering functions*)


splitTrainValidate[dataArray_?ArrayQ,ratio_]:=Module[{train, validate},train = RandomSample[dataArray, Floor[ratio*Length@dataArray]];
validate=Complement[dataArray,train]; {train, validate}];


pcaScree[data_?ListQ,trunc_:All, opts:OptionsPattern[ListPlot]]:=Block[{v},v=Eigenvalues[Covariance[data]];
Row[{ListPlot[Normalize[#,Total],PlotRange->All,AxesLabel->{"eigval index","fraction of variance"},ImageSize->Medium, opts],
ListPlot[Normalize[Accumulate[#],Last],PlotRange->All,AxesLabel->{"eigval index","cumulative fraction of variance"},ImageSize->Medium, opts]}]&@v[[1;;trunc]]];

pcaScree[data_?(Not[ListQ@#]&),trunc_:All]:=data;




dimReducePacket[data_,comps_:4]:=Block[{assc={}, props={"ReducerFunction","ReducedVectors"}},{
assc= DimensionReduction[data,comps,#]&@props;
Return[Association@MapThread[(#1->#2)&,{props,assc}],Block];}]


getLargestClusters[data_, csMethod_:(ClusterClassify[#,20,Method->"Agglomerate"]&), mod_:(#&)]:=
(*Use pattern: plotComponents[plztResponse,3] *)
Module[{classifier, labels,clusterPos, largeClusterData, largePos},
(*dimension reduction needs to be done externally reduce dimensions using automatic choice*)

classifier = csMethod@mod@data; (* obtain classifier within reduced dimensions using default or custom classifier function *)
labels = classifier/@mod@data; (*apply classifier to get the actual clusters *)

(*clusterPos = Table[Flatten@Position[cd, _?(#==l&)],{l,Range@Information[classify,"Classes"][[-1]]}];  (*get cluster positions in the array *)
*)
largePos = Select@@{clusterPos,Length@#>20&}; (*select clusters with more than 20 members per class*)
largeClusterData =Part[data,#]&/@largePos; (*pack data from within large (and assumed therefore significant) clusters*)
<|"dimReduce"-> dimReduce, "largePos"->  largePos, "largeClusterData"-> largeClusterData|> 
(*return association with the clustered data, indices and the dimensionality reduce function*)
]


pointsToHistogram3D[points_,OptionsPattern[ListDensityPlot3D]]:=Block[{ranges,bins,binCounts,transposedBinCounts},ranges=Round[CoordinateBounds[points]];
bins=Append[#,(0.03*(Max@#-Min@#))]&/@ranges;
binCounts=BinCounts[points,Sequence@@bins];
transposedBinCounts=Reverse[Transpose[binCounts,{3,2,1}],{1,2}];
ListDensityPlot3D[#,ColorFunction->"TemperatureMap",PlotLegends->Automatic,OpacityFunction->((2 #)&),ViewPoint->OptionValue[ViewPoint]]&@transposedBinCounts
]



hierarchy[data_?NumericArrayQ, trunc_:{1,Infinity}]:=Module[
{logDm,newDm,ub,res=<||>},
{
(*agglomerate with defulat default distance function*)
ub = Echo@If[MatchQ[#,Infinity],Length@data,#]&@Last@trunc;
res["hCluster"] = HierarchicalClustering`DirectAgglomerate[System`DistanceMatrix[Normal@data],Range@Length@data];
res["hClusterIndices"]=(If[MatchQ[Head@#, HierarchicalClustering`Cluster],HierarchicalClustering`ClusterFlatten[#],#]&/@HierarchicalClustering`ClusterSplit[res["hCluster"],ub]);
Return[res,Module];
}];

hierarchy[distanceMatrix_?SymmetricMatrixQ, trunc_:{1,Infinity}]:=Module[
(*Assumes it's distance matrix on the entry*)
{logDm,newDm,ub,res=<||>},
{
(*agglomerate with defulat default distance function*)
ub = Echo@If[MatchQ[#,Infinity],Length@distanceMatrix,#]&@Last@trunc;
res["hCluster"] = HierarchicalClustering`DirectAgglomerate[distanceMatrix,Range@Length@distanceMatrix];
res["hClusterIndices"]=(If[MatchQ[Head@#, HierarchicalClustering`Cluster],HierarchicalClustering`ClusterFlatten[#],#]&/@HierarchicalClustering`ClusterSplit[res["hCluster"],ub]);
Return[res,Module];
}];


hierarchyPlots[res_, trunc_:{1,Infinity},opts:OptionsPattern[ListPlot]]:=Block[{dp,mp,hp},
(
(*plot results of hierarchy agglomerate with logarithm of default distance function*)
dp = HierarchicalClustering`DendrogramPlot[res["hCluster"],
HierarchicalClustering`TruncateDendrogram->trunc,Axes->{False,True},
AxesOrigin->{-1,Automatic},HierarchicalClustering`LeafLabels->(Length[{#}]&),opts]
)];


distMatrixHistogram[data_,bins_:100,mod_:(Log[#+1]&),OptionsPattern[Histogram]]:=Block[{dmExt},{
dmExt = DistanceMatrix[data];
Echo@Mean@Flatten@dmExt;
Histogram[Flatten@mod@dmExt,bins,"Probability"]}]


outliersAndClusters[hCluster_, splitLevel_]:=Module[{outliers= {},
residualClusters = {}},{
If[MatchQ[Length@#,0],AppendTo[outliers,#],AppendTo[residualClusters,#]]&/@HierarchicalClustering`ClusterSplit[hCluster,splitLevel];
Return[<|"outliers"->outliers,"residualClusters"->residualClusters|>,Module]
}]


plotClusters[clusteredData_,func_:(#&)] := 
Module[{csData,newCenters, newCenterImages},
(*csData=func/@#&/@clusteredData;*)
newCenters =Mean/@clusteredData@"largeClusterData";
newCenterImages = ArrayReshape[#,{11,64}]&/@newCenters;
GraphicsGrid[{MapThread[ plotArrayLabeledResponse[#1,#2]&,{#,Range@Length@#}]&@newCenterImages,
Histogram[Flatten@#,{-1,1,0.01},"Probability"]&/@func[csData]},Spacings->1,AspectRatio->1/3.5,ImageSize->{700,300}]
]


plotClusters1D[data_,clusterIndices_,OptionsPattern[ListLinePlot]]:=Module[{colors, clusteredData,meanVals, stdVals,pDat},
clusteredData = (Part[data,#]&/@#&/@clusterIndices);
meanVals = Flatten[#,1]&/@Mean/@clusteredData;
stdVals = Flatten[#,1]&/@(If[Length@#>1,Variance@#,0*#]&/@clusteredData);
pDat =MapThread[Transpose[{#1,#2}]&,{meanVals, stdVals}];
ListLinePlot[Around@@@#&/@pDat,PlotRange->OptionValue[PlotRange],AspectRatio->OptionValue[AspectRatio],PlotLegends->Placed[#,Right]&@(ToString[#]&/@(Length/@clusteredData))]
]


(* ::Section:: *)
(*SMIM functions*)


loadSMIM[h5file_]:=
<|"bias" ->  Flatten@Import[h5file,{"Datasets","/Measurement_000/Channel_000/Spectroscopic_Values"}],
"chan1"-> Import[h5file,{"Datasets","/Measurement_000/Channel_001/Raw_Data"}],
"chan0" -> Import[h5file,{"Datasets","/Measurement_000/Channel_000/Raw_Data"}]|>;

parseSMIM[phaseOffset_:1.53311,window_:52][dAssc_?AssociationQ]:=Block[{datum, stack=<||>, makeStack, plotStack, parseSwitchingSpec},(

makeStack[data_, chan_:"G"] := 
	Block[{st},
	data//
	{#["x"]["waves"],TakeList[#[chan]["rot"],Flatten@(Dimensions/@#["x"]["waves"])]}&//{First@#,(#-Mean@#)&/@Last@#}&//
	#[[All,3;;]]&//
	MapThread[Transpose[{#1,#2}]&,#]&
	];

plotStack[stk_,chan_:"C"]:=
	Block[{vvec,yerror},(
		vvec =(First@Transpose[#]&/@stk)//First;
		yerror = (Last@Transpose[#]&/@stk)//{Mean@#,StandardDeviation@#}&//MapThread[Around[#1,#2]&,#]&;
		ListLinePlot[Transpose[{vvec,yerror}],PlotRange->All, Axes->False,Frame->True, plotStyle[], FrameLabel->{"bias, V","\[CapitalDelta]smim" <>chan<>", arb. u."}])
	];

parseSwitchingSpec[data_,bias_]:=
(*data would be chan1[[index]]*)
	Block[{smimC=<||>, smimG=<||>,waves, x=<||>,splitSMIMvector},
		(
		x["src"] = Flatten@bias;
		smimC["src"] = BlockMap[Mean,(#["r"]&/@data),window]; 
		smimG["src"] = BlockMap[Mean,(#["i"]&/@data),window];
		
		{smimG["rot"],smimC["rot"]} = Transpose[RotationTransform[phaseOffset][Transpose[{smimC["src"],smimG["src"]}]]];
		x["waves"] = Partition[#,Length@#/(Length@FindPeaks@#-1)]&@bias;
		splitSMIMvector[vec_] := Mean[(#-#[[1]])&/@#[[5;;]]&@TakeList[vec,Length/@x["waves"]]];
		{smimC["mean"],smimG["mean"],x["mean"]} =splitSMIMvector/@{smimC["rot"],smimG["rot"],x["src"]};
		<|"C"->1000 smimC,"G"-> 1000 smimG,"x"->x|>
	)];


datum= parseSwitchingSpec[#,dAssc@"bias"]&/@dAssc@"chan1";
stack["G"] = datum//makeStack[#, "G"]&/@#&//Flatten[#,1]&;
stack["C"] = datum//makeStack[#, "C"]&/@#&//Flatten[#,1]&;
stack["plots"] = Echo@plotStack[stack[#],#]&/@{"G","C"};
stack
)];



End[]


Protect["Calme`*"];


(* ::InheritFromParent:: *)
(*{"adjustPlot","assc","assignSymbol","attrs","attrs$","bandPass","baseFFT","bedOfNails","bgSubtract","chainAssoc","chanHistogram","channelsNames","chanpos","chanposOffset","chans","clearPlot","CloseAllInputCells","colobar1","colorGrads","data","datapos","dimCheck","dimReducePacket","diskRoiMask","distMatrixHistogram","euclidDist","fftshift","figureToClipboard","fitFunc1D","fname","forkBranch","getLargestClusters","grd","gridFileName","growBranch","growForkBranch","hannWindow","header","hierarchy","hierarchyPlots","histogram2D","ifftshift","imageCenter","imageScalebar","initNB","JsonExport","JsonImport","lst","meanSpectraPlot","meshGrid","nestedAssociate","NiceGrid","niceMatrixPlot","normalize\[Bullet]denoise\[Bullet]differentiate","numPartitions","OpenAllInputsCells","outliersAndClusters","\n*)
(*","parseSXM","pcaScree","physicalTicks","plotClusters","plotClusters1D","plotRanger","plotStyle","pointsToHistogram3D","pyBlobs","pyF","pyHistogram","quickShape","randomCheck","readDat","reportChans","reportCore","reportGrid","saveDump","showFFT","singleSpectraMapper","singleSpectraViz","spectraPicker","splitTrainValidate","testListAssociation","todaysDate","x","x$","y","z","$","$$"}*)


EndPackage[]


(* ::Subtitle:: *)
(**)


(* ::Chapter:: *)
(**)
